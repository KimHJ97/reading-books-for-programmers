# 키가 없는 엔트리

과거의 MySQL 버전에서는 기본 스토리지 엔진이 MyISAM 이였고, FK 제약조건을 지원하지 않았다.  
즉, 데이터베이스에서 논리적 관계가 많았지만 참조 정합성을 강제할 수 없었다.  
이러한 문제를 스크립트 작성하여 스크립트를 주기적으로 실행해 모순이 발생했는지 확인하도록 했다.  

테이블 수가 늘어나고 데이터량이 증가함에 따라 품질 제어를 위한 쿼리 수도 많아지고, 스크립트 실행 시간도 길어졌다.  
정말 필요한 것은 사용자가 유효하지 않은 데이터를 입력하려 할 때 애플리케이션이 즉시 에러를 내보내는 것이다.  

## 목표: 데이터베이스 아키텍처 단순화

참조 정합성은 데이터베이스를 적절히 설계하고 운영하는 데 있어 중요한 부분이다.  
어떤 컬럼 또는 컬럼 묶음에 FK 제약조건을 선언하면, 그 컬럼에 들어가는 값은 부모 테이블의 PK 또는 유일키에 존재해야 한다.  

그러나 어떤 소프트웨어 개발자는 참조 정합성 제약조건을 사용하지 말것을 권고한다.  
 - 데이터 업데이트 시 제약 조건과 충돌할 수 있다.
 - 참조 정합성 제약조건을 지원할 수 없는 매우 융툥성 있는 데이터베이스 섥를 사용하고 있다.
 - FK에 데이터베이스가 자동 생성하는 인덱스 때문에 성능에 영향을 받는다고 믿는다.
 - FK를 지원하지 않는 데이터베이스를 사용하고 있다.
 - FK 선언을 위해 문법을 찾아봐야 한다.

<br/>

## 2. 안티패턴: 제약조건 무시

FK 제약조건을 생략하는 것은 데이터베이스 설계를 단순하고 유연하고 빠르게 하는 것으로 보이지만, 다른 방식으로 대가를 치러야 한다.  
참조 정합성을 보장하기 위한 코드를 직접 작성해야 하는 책임을 떠안아야 한다.  

<br/>

### 무결점 코드

많은 사람들이 참조 정합성을 위해 애플리케이션 코드를 작성해 데이터 관계를 만족시키려 한다.  
행을 삽입할 때마다, FK 컬럼의 값이 참조하는 테이블에 존재하는 값인지 확인해야 한다. 또한, 행을 삭제할 때마다 자식 테이블이 적절히 업데이트 되는지 확인해야 한다.  
 - FK 제약조건을 사용하지 않고 참조 정합성을 만족하기 위해서는 변경전에 별도의 SELECT 쿼리를 실행해 해당 변경이 참조 정합성을 꺠뜨리지 않는지 확인해야 한다.
```sql
-- 키 확인 후 행 삽입
SELECT account_id
FROM Accounts 
WHERE account_id = 1;

INSERT INTO Bugs (reported_by) VALUES (1);

-- 행 삭제시 자식 행이 없는 것을 확인
SELECT bug_id
FROM Bugs
WHERE reported_by = 1;

DELETE
FROM Accounts
WHERE account_id = 1;
```

이러한 방법에도 SELECT 쿼리를 실행한 시점에 해당 행이 변경될 수도 있다. (깨진 참조)  
유일한 해결책은 확인하기 전에 테이블 잠금 설정하고, 데이터를 삭제한 후 잠금을 해제하는 것이다.  
이러한 잠금을 필요로 하는 아키텍처는 높은 동시성과 확장적응성이 필요한 환경에서는 제대로 동작하지 않을 수 있다.  

<br/>

### 오류 확인

애플리케이션에서 오류 확인을 하려면 아래 같은 쿼리를 모든 참조 관계에서 처리해야 한다.  

```sql
SELECT b.bug_id, b.status
FROM Bugs b 
    LEFT OUTER JOIN BugStatus s
        ON (b.status = s.status)
WHERE s.status IS NULL;
```
<br/>

### 내 잘못이 아니야

애플리케이션의 여러 함수에서 비슷한 데이터베이스 업데이트를 수행하기 쉽다.  
코드를 수정해야 하는 경우, 모든 경우에 대해 문제가 없도록 변경을 적용했는지 확신하기 어렵다.  

데이터베이스는 일관성 있게 유지해야 한다. 즉, 데이터베이스 내 참조가 항상 유효해야 한다. 그러나 데이터베이스에 접근하는 모든 애플리케이션과 스크립트가 올바르게 변경을 가하는지는 확신할 수 없다.  

<br/>

### 진퇴양난 업데이트

많은 개발자들은 여러 테이블의 관련된 컬럼을 업데이트할 때 불편해지기 때문에 FK 제약조건 사용을 꺼린다.  
예를 들어, 다른 행의 의존하는 어떤 행을 삭제 시, FK 제약조건을 위반하지 않기 위해 자식 행을 먼저 삭제해야 한다.  

문제는 자식 행이 참조하고 있는 컬럼을 UPDATE할 때 발생한다.  
부모를 업데이트하기 전에는 자식 행을 업데이트할 수 없고, 자신을 참조하는 자식 행을 업데이트하기 전에는 부모를 업데이트할 수 없다.  
둘을 동시에 변경해야 하지만, 두 개의 분리된 업데이트 문으로는 해결이 불가능하다.  

```sql
-- DELETE 쿼리
DELETE FROM BugStatus WHERE status = 'BOGUS' ; --에러 

DELETE FROM Bugs WHERE status = 'BOGUS' ;
DELETE FROM BugStatus WHERE status = 'BOGUS' ; --재시도 성공

-- UPDATE 쿼리
UPDATE BugStatus SET status = 'INVALID' WHERE status = 'BOGUS'; --에러
UPDATE Bugs SET status = 'INVALID' WHERE status = 'BOGUS'; --에러
```
<br/>

## 3. 안티패턴 인식 방법

 - 어떤 값이 한 테이블에는 있고 다른 테이블에는 없는지 확인하려면 쿼리는 어떻게 작성해야 하는가
 - 테이블에 삽입하면서 다른 테이블에 어떤 값이 있는지를 확인하는 빠른 방법이 없는가
    - 이는 부모행이 존재하는지 확인하려는 것임
    - FK가 이를 자동으로 확인해주며, 효율적으로 확인하기 위해 부모 테이블의 인덱스를 활용한다.

<br/>

## 4. 안티패턴 사용이 합당한 경우

 - DB에서 지원하지 않는 경우
    - 과거 MySQL의 MyISAM 스토리지 엔진
    - SQLite 3.6.19 버전 이하
 - 극단적으로 유연한 데이터베이스를 설계하는 경우

<br/>

## 5. 해법: 제약조건 선언하기

일본어에는 포카요케라는 표현이 있다. 이 용어는 오류 검증이라는 뜻으로 오류를 방지하거나 바로잡거나 또는 발생하는 즉시 관심을 가져 제품의 결함을 제거하는 데 도움이 되는 생산 공정을 뜻한다.  
데이터베이스 설계에서도 참조 정합성을 강제하기 위해 FK를 사용하는 방법으로 포카요케 원리를 적용할 수 있다. 데이터 정합성 오류를 찾아내 정정하는 대신, 처음부터 잘못된 데이터가 입력되지 않도록 한다.  

 - FK를 사용하면 불필요한 코드를 작성하지 않아도 되고, 데이터베이스를 변경할 떄도 모든 코드가 동일한 제약조건을 따르는 것을 확신할 수 ㅇㅆ다.
 - 코드 개발기간 단축과 디버깅 유지보수에 드는 시간도 감소한다.
```sql
CREATE TABLE bugs (
    ...
    reported_by     BIGINT UNSIGNED NOT NULL,
    status          VARCHAR(20) NOT NULL DEFAULT 'NEW',
    FOREIGN KEY (reported_by) REFERENCES Accounts(account_id),
    FOREIGN KEY (status) REFERENCES BugStatus(status)
);
```
<br/>

### 여러 테이블 변경 지원

FK 제약조건에는 단계적 업데이트 옵션이 있다.  
부모 행을 업데이트 또는 삭제할 경우 데이터베이스가 해당 부모를 참조하는 자식 행을 알아서 처리해준다.  

```sql
CREATE TABLE bugs (
    ...
    reported_by     BIGINT UNSIGNED NOT NULL,
    status          VARCHAR(20) NOT NULL DEFAULT 'NEW',
    FOREIGN KEY (reported_by) REFERENCES Accounts(account_id)
        ON UPDATE CASCADE
        ON DELETE RESTRICT,
    FOREIGN KEY (status) REFERENCES BugStatus(status)
        ON UPDATE CASCADE
        ON DELETE SET DEFAULT
);
```
<br/>

### 오버헤드?

FK 제약조건은 약간의 오버헤드가 있는 것은 사실이다. 하지만, 다른 대안과 비교했을 때 FK가 훨씬 효율적이다.  
FK는 사용하기 쉽고, 성능 향상과 데이터 변경 시 참조 정합성을 일관적으로 유지하는 데 도움이 된다.  

 - INSERT, UPDATE, DELETE 전에 데이터 확인을 위한 SELECT 쿼리를 실행할 필요가 없다.
 - 여러 테이블을 변경하기 위해 테이블 잠금을 사용할 필요가 없다.
 - 불가피하게 생기는 고아 데이터를 정정하기 위해 품질 제어 스크립트를 주기적으로 실행할 필요가 없다.

