# HTTPS

HTTPS는 서로 다른 두 컴퓨터가 네트워크를 통해 안전하게 메시지를 주고받기 위해 만든 프로토콜이다. HTTPS는 TCP 대신 전송 계층 보안(TLS) 프로토콜을 기반으로 하는 HTTP 라고 이해하면 된다.  

<br/>

## HTTPS를 사용하는 이유

네트워크 패킷 캡처 프로그램으로 클라이언트가 보낸 모든 내용을 확인할 수 있다.  

<br/>

이처럼 네트워크로 암호화되지 않은 메시지를 주고받을 때는 제 3자가 신용카드나 비밀번호 같은 민감한 정보를 염탐하거나, 메시지를 원하는 형태로 위변조 할 위험이 있다.  

<br/>

HTTPS를 사용하면 서버와 클라이언트가 주고받는 메시지를 암호화하여 제 3자가 보더라도 암호화되어 해석할 수 없다. 메시지를 암호화/복호화할 때 사용하는 키는 HTTPS로 메시지를 주고받는 두 컴퓨터만 알고 있다.  

<br/>

HTTPS는 4계층에서 동작하는 TLS와 달리, 7계층에서 동작한다. 그래서, 키를 안전하게 교환하는 것 외에도 7계층 정보인 HTTP의 도메인 주소가 신뢰할 수 있는지 검사하는 기능도 제공한다.  

<br/>

## 2. HTTPS의 구성 요소

### TLS 버전

HTTPS는 TLS를 기반으로 하며 TLS 버전에 따라 사용 가능한 암호화 목록과 안전성이 달라진다. 높은 TLS 버전을 사용하면 오래된 하드웨어나 소프트웨어를 지원하지 않아서 호환성 문제가 발생할 수 있지만, 더 강력한 암호 알고리즘을 사용하여 해킹 위험이 줄어든다.  

<br/>

 - __TLS 1.0__
    - 1990년대 말에 제정된 최초의 TLS 버전
    - TLS 프로토콜 기반인 SSL 3.0과 일부 호환된다.
    - 암호 알고리즘에 취약점이 발견되어 2020년 3월부터 TLS 1.0 및 1.1 지원 중단
 - __TLS 1.1__
    - 1.0 프로토콜에서 발견된 취약점 개선 및 더 강력한 암호 알고리즘 사용
    - 1.0과 마찬가지로 모든 브라우저에서 사용 중단 선언
 - __TLS 1.2__
    - TLS 1.1에서 서명, 랜덤 함수 등에서 사용하는 MD5/SHA-1 해시 함수들을 사용할 수 없게 제거하고, 알고리즘을 SHA-2 기반으로 변경

<br/>

### 메시지 암호 키 교환

키 교환은 RSA 알고리즘과 디피-헬먼(DHE) 알고리즘 중 한 가지 방법을 사용한다.  
두 방법 모두 소수와 이산대수의 특징을 이용하여 불가능에 가까운 연산을 요구함으로써, 제 3자가 연결 과정을 보더라도 키를 유추할 수 없게 한다.  

 - __RSA__
    - RSA 알고리즘을 사용한 키 교환 방식은 취약하여 TLS 1.3부터는 지원하지 않음
    - RSA 알고리즘을 사용해 키 교환할 때, 모든 클라이언트와의 키 교환이 서버 공개키 하나에 의존하기 때문에 비공개키가 한 번이라도 노출되면 과거에 주고받았던 메시지나 미래에 주고받을 모든 메시지까지 복호화가 가능하다.
 - __DHE, ECDHE__
    - 디피-헬먼 알고리즘은 공개키를 주고받은 이후 추가 과정을 더해 키를 만든다.
    - 떄문에, 비밀키가 노출되더라도 과거에 주고받았던 메시지가 노출될 일은 없다.
    - 하지만, 비밀키가 노출되면 미래에 주고받을 메시지는 여전히 노출될 수 있다.
    - 시간이 지나면서 취약점이 발견되어 타원 곡선 디피-헬먼 알고리즘이 사용된다.

<br/>

### 인증서(X.509)

HTTPS 통신을 하기 위해서는 반드시 인증서가 필요하다. X.509는 이러한 형태의 인증서를 위한 표준으로 신뢰할 수 있는 인증 기관(CA)에서만 발급이 가능하다.  
 - X.509 인증서는 발행 기관, 인증서 버전, 고유 번호, 인증서 소유자 및 소유자 정보 등을 포함한다.
 - __인증서 서명__
    - 모든 인증서에는 인증서 변조를 막기 위한 서명이 있다.
    - 서명은 비밀키를 알고 있는 기관에서만 만들 수 있고, 인증서 정보가 변조되면 서명이 바뀌거나 일치하지 않으므로 변조 사실을 알 수 있다.
    - 인증서를 받은 클라이언트는 서명을 확인하는 것만으로 인증서를 보낸 서버가 신뢰할 수 있는지 확인할 수 있다.

<br/>

#### 인증서 검증 프로세스

 - 모바일 기기를 포함한 대부분 운영체제 또는 웹 브라우저는 자체적으로 신뢰할 수 있는 최상위 기관의 CA의 인증서(인증서 번들)를 가지고 있다.
 - 서버가 인증서를 보내면 인증서 발급 기관에 해당하는 상위 인증서를 가져온다. (이 과정은 최상위 인증서를 찾을 때 까지 반복)
 - 최상위 인증서 안에 있는 공개키를 이용해 중간 기관 인증서 서명을 복호화한다. 복호화에 성공시 최상위 기관 인증서의 해시 값을 가져올 수 있다.
 - 3번 과정에서 얻은 해시 값이 인증서 번들에 있는 최상위 기관 인증서 서명과 일치하면, 서버 인증서 서명과 중간 기관의 공개키를 이용해 3번 과정을 다시 반복한다.

<br/>

## 3. HTTPS 핸드셰이킹 과정

 - __클라이언트__
    - HTTP 연결이 되는 순간 클라이언트는 서버로 Hello 메시지를 보낸다.
    - Hello 메시지 안에는 암호화 키에 사용할 랜덤값, 클라이언트가 사용할 수 있는 암호화 목록이 있다.
 - __서버__
    - 클라이언트로부터 Hello 메시지를 받은 서버는 클라이언트의 Hello 메시지 안에 포함된 암호화 목록 중 선호하는 암호를 선택하여 서버 랜덤값과 서버 인증서와 함께 클라이언트로 전달한다.
 - __인증서 검증__
    - 인증서와 암호화 방식을 받은 클라이언트는 인증서가 신뢰하는 기관에서 발급한 것인지 검증한다. 이후 암호화 방식에 따라 RSA 또는 ECDHE에 맞는 형태로 키 교환을 시도한다.
    - 신뢰할 수 있는 인증서라면 클라이언트는 서버와 클라이언트 모두가 사용할 Premaster 값을 생성한 다음 공개키로 암호화하여 서버로 보낸다. 이떄, RSA 방식 키 교환은 Premaster 값을 그대로 암호화하여 보내지만, DH 또는 ECDHE는 주고받은 파라미터를 이용해 Premaster 값을 계산한다.
 - __대칭 키 생성__
    - 서버와 클라이언트는 서버 랜덤값과 클라이언트 랜덤값, Premaster 키를 조합해 암호화에 사용할 키를 만든다. Premaster 키는 키 교환 방식에 따라 길이가 다르므로 교환 방식에 따라 최종적으로 사용할 대칭 키를 만드는 방법도 조금 다르다.

