# 가독성 높은 코드를 작성하는 법

## 1. 생산성 개선

 - 개발자 대부분은 사실 코드를 쓰는 것보다 읽는 것에 개발 시간을 더 많이 할애한다.
 - 코드를 읽을 일이 많아진다는 것은 곧 가독성을 높여야 생산성을 개선한다는 뜻이다.

<br/>

### 1-1. 개발 규모와 생산성의 관계

새로운 개발자가 팀에 합류한 경우 그 사람이 코드 베이스 전체를 이해하는 데 시간이 걸린다. 또, 대규모 코드베이스에서 코드 수정시 코드의 가독성이 충분히 높으면 어떤 코드를 수정했을 때의 영향 범위를 쉽게 확인하고 안전하게 수정할 수 있다.  

지금 당장 만족스러운 코드를 작성했더라도, 향후 지속적으로 개발하기 위해 코드의 가독성을 재차 점검해야 한다. 코드를 작성한 후에도 코멘트를 추가하고, 테스트를 작성하고, 리팩토링 하는 등 지속적으로 개선한다.  

<br/>

## 2. 가독성 높은 코드를 작성하기 위한 요건

### 2-1. 가독성과 관련된 지표

코드 가독성을 높이기 위해서는 여러 관점에서 코드의 가독성을 평가해야 한다.  
예를 들어, 코드 길이는 가독성과 관련이 있지만, 이에 집착해서는 안 된다. 덩치가 큰 함수가 읽기 어려운 것은 당연하지만, 그렇다고 함수를 너무 세분화하면 오히려 전체 구조를 파악하기 어려운 코드가 될 수 있다.  

 - __단순한 코드__
    - 코드 자체가 단순하면 동작을 쉽게 이해할 수 있다.
 - __의도가 명확한 코드__
    - 코드의 가독성을 높이려면 코드의 동작뿐만 아니라 대략적인 의미와 작성 이유도 추측하기 쉬워야 한다.
    - flag 변수 이름을 통해 어떤 상태를 나타내는 참/거짓 값인 것을 유추할 수 있지만, 그 이상의 정보를 읽어낼 수 없다. 반면에, isVisible 이라는 변수 이름을 사용하면 무언가 표시할 수 있는 것이 있고, 값이 true일 때 표시된다는 것까지 짐작할 수 있다.
 - __독립성이 높은 코드__
    - 코드 규모가 커질수록 모든 코드를 세밀하게 파악하는 것은 어렵다. 함수, 클래스, 모듈과 같은 코드 집합별로 역할과 동작을 높은 추상도로 파악할 필요가 있다.
    - 각 코드 집합의 책임 범위를 명확히 한다.
    - 다른 집합과의 의존 관계를 제한한다.
 - __구조화된 코드__
    - 가독성을 높이기 위해서는 들여쓰기, 줄바꿈 형식 등 코드 외형 일관성 유지도 중요하지만, 뿐만 아니라 함수, 클래스, 모듈의 구조에도 주의를 기울여야 한다.
    - 클래스 간 의존 관계나 추상화 계층의 구성 등 여러 측면에서 코드를 구조화하면 가독성이 높은 코드를 구현할 수 있다.

<br/>

### 2-2. 가독성을 높이기 위해 주의할 점

 - __지식과 기술의 선택__
    - 무엇을 위해 그 아키텍처를 사용하는지, 어떤 환경에서 그것이 유효하게 작동할지를 잘 이해하고, 아키텍처가 새로운 시대에도 유효할지 판단한다.
 - __가치와 복잡도의 균형__
    - 새로운 기능을 구현할 때는 해당 기능이 제공하는 가치와 기능 구현으로 증가하는 코드베이스의 복잡한 정도를 신중하게 고려해야 한다.
 - __검증의 자동화__
    - 개발자가 직접 코드의 정확성을 확인하는 것보다 컴파일러나 정적 분석 도구를 활용하면 가독성 높은 코드를 작성하기 수월하고, 버그가 발생할 가능성도 줄일 수 있다.

<br/>

## 3. 대표적인 프로그래밍 원칙

소프트웨어 개발 분야에는 가독성을 높이기 위해 제시된 매우 다양한 프로그래밍 원칙이 있다. 하지만, 유용한 원칙도 무분별하게 적용하면 오히려 가독성을 떨어뜨릴 수 있다. 따라서, 새롭게 프로그래밍 원칙을 적용할 때에는 신중하게 선별해야 한다.  
 - 보이스카우트 원칙
 - YAGNI(You Aren't Gonna Need It)
 - KISS(Keep It Simple Stupid)
 - 단일 책임의 원칙
 - 성급한 최적화는 모든 악의 근원

<br/>

### 3-1. 보이스카우트 원칙

로버트 C. 마틴이 제안한 원칙으로 코드를 변경할 때는 주변을 둘러보고 소소한 개선이 필요한 부분을 함께 살펴보아야 한다는 원칙이다.  
보이스카우트에서 캠프장을 사용한 후에는 사용하기 전보다 더 깨끗히 청소하고 떠나라라는 규칙에서 제안되었다.  

 - 추가: 누락된 주석이나 테스트 추가하기
 - 삭제: 불필요한 의존 관계, 구성 요소, 조건문 삭제하기
 - 리네이밍: 클래스, 함수, 변수 등의 이름을 적절하게 바꾸기
 - 세분화: 너무 큰 클래스나 함수, 지나치게 깊은 계층 구조, 연쇄적인 호출을 잘게 나누기
 - 구조화: 의존 관계, 추상화 레이어, 상속의 계층 구조를 적절히 구성하기

```java
// ❌ Bad
void updateViewProperties(ViewType viewType) {
    switch (viewType) {
        case A:
            view1.isVisible = true;
            view1.text = "Case A";
        case B:
            view1.isVisible = false;
            view1.text = "Case B";
        ..
        case Y:
            view1.isVisible = true;
            view1.text = "Case Y";
    }
}

// ✔ Good
@RequiredArgsConstructor
public enum ViewType {
    A(true, "Case A"),
    B(false, "Case B"),
    ..
    Y(true, "Case Y");

    private boolean visible;
    private String text;

    public boolean getVisible() {
        return visible;
    }

    public String getText() {
        return text;
    }
}

void updateViewProperties(ViewType viewType) {
    view1.isVisible = viewType.getVisible();
    view1.text = viewType.getText();
}
```
<br/>

### 3-2. YAGNI

YAGNI는 '그런 건 필요하지 않아'를 뜻하는 영문 약자로, 익스트림 프로그래밍 원칙 중 하나이다.  
불확실한 미래를 위해 현재 필요하지 않은 기능을 미리 구현해도 정작 사용되지 않는 경우가 많다는 의미이다.  

<br/>

### 3-3. KISS

KISS는 록히드사의 엔지니어였던 켈리 존슨이 주장했으며, 바보스러울 정도로 단순하게 만들어라라는 의미를 담고 있다.  
 - Keep It Small and Simple, Keep It Simple Stupid
 - 불필요한 것을 추가하지 않는 것이 단순함을 향한 지름길이다.

<br/>

### 3-4. 단일 책임의 원칙

단일책임원칙은 SOLID라는 객체지향 원칙 중 하나로, 클래스 하나에 부여하는 책임과 역할은 오직 하나뿐이어야 한다는 의미를 가진다.  
 - 클래스가 가지는 메서드 수나 코드 행 수가 반드시 책임의 크기와 비례하지는 않다.
```java
// ❌ Bad: 뭐든지 하는 메서드를 가진 클래스
class Alviss {
    public Object doEverything(UniverseState state) {
        // ..
    }
}

// ❌ 클래스 하나가 다수의 정보를 관리
class LibraryBookRentalData {
    // 도서 정보: ID와 제목
    private List<Long> bookIds;
    private List<String> bookNames;

    // 도서 대출 정보: 이용자 이름과 반납 기한
    private Map<Long, String> bookIdToRenterNameMap;
    private Map<Long, LocalDateTime> bookIdToDueDateMap;
}

// ✔ 책임 분리
// 도서 정보를 BookModel로, 이용자 데이터를 UserModel로 분리
```
<br/>

### 3-5. 섣부른 최적화는 만악의 근원

충분한 효과를 기대할 수 없는 최적화는 쓸모없을 뿐만 아니라 오히려 코드를 복잡하게 만들고 가독성을 떨어뜨리는 결과를 가지고 온다.  

<br/>

### 3-6. 정리

 - 보이스카우트 규칙: 코드를 변경할 떄는 기존 코드를 함께 개선한다.
 - YAGNI: 기능은 필요할 때만 구현한다.
 - KISS: 구현을 단순하게 유지한다.
 - 단일 책임의 원칙: 클래스의 책임을 명확하고 작게 유ㅣ한다.
 - 성급한 최적화는 만악의 근원: 코드를 복잡하게 만드는 최적화를 피한다. 필요하다면 성능을 측정한다.

