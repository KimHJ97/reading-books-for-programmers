# 웹 세계의 이해

## 1. 웹의 기초: 웹 개발 히스토리

### 1-1. 월드 와이드 웹의 탄생

- **팀 버너스리의 등장**
  - 1980년대 말 CERN에서 일하던 영국 과학자 팀 버너스리는 전 세계 어느 컴퓨터에서나 접근하는 상호 연결된 문서의 세상을 상상하면서 웹의 기본적인 개념과 기술을 개발하기 시작한다.
- **월드 와이드 웹의 출현**
  - 1991년 팀 버너스리는 이 시스템을 공개하고 월드 와이드 웹으 소개한다.
  - 현재 동적이고 멀티미디어 풍부한 플랫폼과는 거리간 먼 이 초기 웹은 주로 텍스트 정보의 웹이었다.
  - 하이퍼텍스트를 통해 문서가 서로 연결되어 있어 사용자는 전 세계 다양한 서버에 호스팅된 콘텐츠에 자유롭게 접근할 수 있게 되었다.
- **첫 번쨰 웹사이트와 기초 기술**
  - HTML: 웹의 구성 요소로 콘텐츠의 구조를 정의
  - URI: 웹 상의 각 자원에 고유한 주소를 제공하는 시스템
  - HTTP: HTML을 전송하는 프로토콜

### 1-2. 웹 1.0, 2.0 그리고 3.0의 진화

- **웹 1.0: 정적 웹**
  - 웹 1.0은 웹의 가장 기초 단계이며 웹 탄생부터 2000년대 초까지 지속된다.
  - 정적 내용: 초기 웹사이트는 정보 제공용으로 사용되었다.
  - 제한된 사용자 상호 작용: 사용자 활동은 대부분 정보를 읽는 데 국한되었다.
  - 웹마스터 시대: 콘텐츠 생성은 주로 웹마스터에 의해 이루어졌다. 일반 사용자는 온라인에 게시할 수 있는 도구나 플랫폼을 충분히 갖추지 못했다.
- **웹 2.0: 사회화 웹**
  - 2000년대 중반에 등장한 웹 2.0은 정적 웹사이트에서 동적인 웹 애플리케이션으로 패러다임의 변화를 나타낸다.
  - 사용자 생성 콘텐츠: 위키백과, 블로거, 유튜브 등의 플랫폼이 콘텐츠 생성을 확장한다.
  - 동적 상호 작용: 자바스크립트와 AJAX의 발전으로 웹사이트는 전체 페이지를 다시 로드하지 않고도 사용자의 입력에 반응하여 더욱 상호 작용적으로 변화한다.
  - 커뮤니티와 협업: 페이스북과 트위터 등 소셜 네트워킹 사이트는 전 세계적인 연결의 시대를 선언한다.
- **웹 3.0: 시맨틱 웹(그 이상)**
  - 현재 웹은 더 지능적이고 개인화된 특징을 가진 웹 3.0으로 전환하는 과정에 있다.
  - 데이터 연결: 정봅는 의미 있게 상호 연결된다.
  - AI와 개인화: 인공지능 알고리즘을 활용해 웹은 사용자가 관심을 가질 내용을 예측한다.
  - 분산화와 개인 정보 보호: 블록체인 등의 기술을 통해 사용자가 자신의 데이터를 통제할 수 있는 분산된 웹으로 이동을 진행한다.

## 2. 렌더링의 이해: 브라우저에서의 웹 페이지 렌더링 메커니즘

### 2-1. 브라우저의 작동 원리

브라우저는 단순히 인터넷 접속의 수단이 아닌 다양한 기능을 수행하는 복잡한 도구이다. 웹 페이지를 구성하는 기본적인 코드와 이미지 등을 포함하는 리소스를 입력으로 받아 처리하며 최종적으로 사용자가 상호 작용하는 시각적인 인터페이스로 변환된다.

- **리소스 가져오기: HTML, CSS, 자바스크립트, 이미지 및 멀티미디어, 폰트, 아이콘 등**
  - URL을 입력하거나 링크를 클릭하면 첫 번쨰 단계는 주로 HTML 파일인 필요한 리소스를 가져오는 것이다. 이는 브라우저의 네트워킹 계층에 의해 이루어지며 서버에 연결하여 데이터를 검색한다.
- **파싱 및 구축**
  - HTML 콘텐츠를 입력받은 브라우저는 파싱 과정을 시작한다. 이 과정에서 HTML 문자열은 DOM 이라는 구조로 변환된다.
  - HTML 요소는 트리의 노드로 표현되며, CSS를 파싱하여 또 다른 트리 구조인 CSSOM을 형성한다.
- **조합 및 렌더링**
  - 브라우저는 DOM과 CSSOM을 결합해 렌더링 트리를 형성한다. 이 트리는 페이지의 시각적 레이아웃을 나타내고 해당 CSS 규칙에 따라 스타일이 지정된 모든 보이는 DOM 요소를 포함한다.
- **자바스크립트의 역할**
  - 브라우저가 DOM을 변경하는 자바스크립트를 만나면, 렌더링 파이프라인의 일부를 재계산해야 할 필요가 생길 수 있다. 때문에, 자바스크립트 실행에 따라 병목 현상이 일어날 수 있는 만큼 신중하게 해야한다.
    - 과도한 DOM 조작: 자주 DOM을 변경하면 브라우저가 레이아웃과 렌더링을 반복해야 하므로 성능 저하가 일어난다.
    - 비효율적인 이벤트 리스너: 많은 이벤트 리스너는 이벤트 처리 시간을 증가시켜 성능을 저하한다.
    - 긴 실행 시간의 스크립트: 오래 실행되는 자바스크립트는 페이지의 다른 부분을 대기 상태로 만들어 사용자 경험을 해친다.
    - 동기적 리소스 로딩: 리소스를 동기적으로 로드하면 페이지 로드 시간이 길어질 수 있다.
- **리소스 관리 및 비동기 로딩 전략(최적화)**
  - 자바스크립트와 CSS 파일에 async 또는 defer 속성을 사용함으로써 브라우저는 페이지의 다른 부분을 로딩하는 동안 해당 파일을 백그라운드에서 로드한다. 또한 자바스크립트와 CSS 파일을 최적화하여 용량을 줄이는 것도 중요하다.
  - 이미지 리소스도 최적화가 필요하다. 지연 로딩 방식을 적용하여 페이지 로드 시간을 줄일 수 있으며, 이미지를 압축하고 적절한 형식으로 변환하여 리소스의 크기를 최소화하는 것도 중요하다.

### 2-2. 렌더링 트리 구성 이후: 리플로우, 리페인트

- **리플로우: 레이아웃 계산**
  - **리플로우는 브라우저가 렌더링 트리의 요소 위치와 크기를 계산하는 과정이다.**
  - 브라우저 창의 크기를 변경하거나 요소의 내용을 변경할 떄 트리 요소의 기하학적 구조에 영향을 주는 변경이 발생할 떄마다 리플로우가 발생한다.
- **리페인트: 픽셀 색칠하기**
  - 리플로우 단계가 완료되면, 브라우저는 리페인트 단계로 넘어간다.
  - **리페인트는 화면의 일부 또는 전체를 다시 그리며 픽셀을 채우느 과정이다.**
  - 요소의 색상과 그림자 변화 또는 레이아웃에 영향을 주지 않는 다른 시각적 스타일의 변경으로 리페인트가 발생한다.
- **리액트와 가상 DOM을 활용한 효율적인 웹 애플리케이션 렌더링 전략**
  - 리액트는 UI를 구축하고자 가상 DOM을 사용하는데, 이는 효율적인 UI 업데이트와 렌더링을 최적화한다.
  - 상태 변경이 발생하면 리액트는 먼저 가상 DOM에 그 변경 사항을 적용하고 이후 필요한 최소한의 DOM을 조작해 실제 DOM을 업데이트한다.
  - 이 과정에서 리플로우와 리페인트를 최적화하는 것이 중요하다. 리플로우는 페이지 레이아웃 재계산 과정을 말하며, 리페인트는 실제 화면에 표시되는 요소의 시각적 변경을 의미한다. 성능을 최적화하고자 리액트 개발자는 shouldComponentUpdate, React.memo 같은 기법을 사용하여 불필요한 렌더링을 방지할 수 있다. 또한, 컴포넌트를 세분화하여 전체 UI가 아닌 일부만 업데이트되도록 하여 리페인트 과정을 최소화하는 데 도움을 준다.

## 2-3. 웹의 기본 구성 요소: HTML, CSS, JavaScript

### 3-1. HTML: 웹 페이지의 구조 정의

팀 버너스리가 HTML 개발하게 된 배경은 학술 논문의 구조화와 관련이 있다. 일반적인 인쇄물과 달리 학술 논문은 다양한 참조, 주석, 복잡한 구조 등을 포함한다. 웹의 초창기에는 인터넷에 학술적 문서를 효과적으로 관리하고 연결하는 방법이 필요했다. 팀 버너스리는 CERN에서 근무하던 당시 하이퍼텍스트를 사용하여 인터넷상의 정보를 서로 연결하고 쉽게 접근하는 시스템을 제안했다. 이 시스템은 학술 논문처럼 복잡한 문서를 웹상에서 구조화하고 서로 연결된 링크를 통해 정보를 탐색할 수 있게 만들었다.

- HTML 문서 구조
  - HTML 문서는 꺾쇠괄호로 둘러싸인 일련의 요소로 구성되며 대부분은 시작 태그와 종료 태그의 쌍으로 나타난다.
  - 검색 엔진을 최적화하는 Head 메타 정보
    - 문서 문자 인코딩: 페이지의 문자 인코딩을 명시
    - 웹 페이지 설명: 페이지의 내용을 요약하는 짧은 설명 (검색 결과에 보이는 짧은 텍스틀 표시된다.)
    - 키워드: 과거에는 이 태그가 주요 키워드를 나열하여 검색 엔진 최적화에 큰 영향을 주었지만, 최근에는 덜 중요해지며 잘못 사용시 부정적인 영향을 준다.
    - 로봇 메타 태그: 검색 엔진 봇에게 페이지의 인덱싱 방법을 지시한다. noindex는 페이지를 인덱스에 포함하지 말라는 지시이며, nofollow는 페이지의 링크를 따라가지 말라는 지시이다.
    - Open Graph 태그: 소셜 미디어 플랫폼에서 웹 피이지를 공유할 떄 어떻게 페이지 정보를 표시할지 정의하는 태그이다. (페이스북, 트위터 등 다양한 플랫폼에서 활용)
    - Canonical 태그: 중복된 내용이 있는 페이지 중 어느 페이지가 원본 페이지인지를 검색 엔진에 알려준다.

```html
<!DOCTYPE html>
<html>
  <head>
    <title>문서의 제목</title>
    <meta chartset="UTF-8" />
    <meta
      name="description"
      content="이 페이지는 메타 정보와 SEO에 대해 설명한다."
    />
    <meta name="keywords" content="SEO, 메타 정보, 검색 엔진, 최적화" />
    <meta name="robots" content="noindex,nofollow" />
    <meta property="og:title" content="페이지 제목" />
    <meta property="og:description" content="페이지 설명" />
    <meta property="og:image" content="이미지 URL" />
    <link rel="canonical" href="https://www.example.com/original-page" />
  </head>
  <body>
    문서의 내용
  </body>
</html>
```

### 3-2. CSS: 웹 페이지 스타일링

CSS는 페이지의 시각적 표현을 담당한다. 웹 페이지의 레이아웃, 색상, 타이포그래피, 애니메이션 등을 제어하여 HTML로 만들어진 기본 구조를 시각적으로 매력적이고 상호 작용적인 경험으로 전환한다.

CSS는 1994년 하콘 뷔엠 리에에 의해 처음 제안되어 내용을 그 표현과 분리하는 방법을 제공한다. 이를 통해 스타일을 선택적으로 요소에 적용해 인라인 스타일링의 중복성을 줄이면서 일관성을 달성한다.

- 선택자: 스타일에 적용될 HTML 요소를 결정한다.
- 속성: 어떤 부분의 요소가 꾸며질지 정의한다.
- 값: 선택한 속성에 대한 스타일의 세부 사항을 지정한다.

### 3-3. 자바스크립트: 웹 페이지 동적 처리 및 상호 작용 구현

자바스크립트는 웹 페이지에 상호 작용성을 부여하는 프로그래밍 언어이다. HTML과 CSS가 웹 페이지의 구조와 스타일을 정의하는 반면 자바스크립트는 기능을 추가한다.

최초의 웹 페이지에 간단한 상호 작용을 추가하는 목적으로 개발된 자바스크립트는 큰 발전을 이루며 ECMAScript의 도입으로 이 언어는 전통적인 백엔드 언어들과 맞먹는 기능과 능력을 갖추게 되었다.

- 이벤트 기반: 클릭과 키 입력 또는 페이지 로드 등의 동작이 자바스크립트 함수를 트리거 할 수 있다.
- 객체 지향: 순수한 객체 지향은 아니지만 자바스크립트는 객체, 프로토타입, 상속을 지원한다.
- 일급 함수: 자바스크립트의 함수는 변수에 할당되거나 인수로 전달되거나 다른 함수에서 반환될 수 있다.
- 동적 타이핑: 자바스크립트는 변수의 타입이 실행 시간에 결정되고 동일한 변수에 다양한 타입의 값을 할당하는 동적 타이핑 언어이다.
- 프로토타입 기반 상속: 클래스 기반 상속 대신 프로토타입 기반 상속 모델을 사용한다. 객체는 프로토타입 객체에서 속성과 메서드를 상속받으며 이는 코드 재사용과 다양한 삭송 패턴을 가능하게 한다.
- 비동기 처리: 자바스크립트는 원래 단일 스레드 기반으로 작동하지만 콜백 함수, 프로미스, async/await를 통해 비동기 작업을 처리한다. 웹 애플리케이션에서 네트워크 요청이나 I/O 작업을 다룰 떄 유용하다.
- 클로저: 클로저를 통해 함수 내부의 변수를 외부에서 접근하지 못하게 하면서도 해당 함수가 실행될 떄 이 변수들에 접근할 수 있도록 한다.

## 4. 네트워킹 기초: 도메인, URL, 라우팅

### 4-1. 도메인과 URL: 웹 리소스의 주소 체계

- 도메인: 웹사이트의 집주소
- URL: 집 안의 특정 방안으로 가는 경로 (웹상에서 특정 리소스를 정하는 데 상세한 정보 제공)
- 세그먼트: URL 내의 경로 부분을 세분화한 것으로 각 세그먼트는 슬래시로 구분된다.
- 슬러그: URL의 마지막 부분으로 특정 페이지나 리소스를 나타내는 사람이 읽을 수 있는 키워드

### 4-2. 도메인 네임 시스템: 인터넷 주소 지정의 핵심

DNS는 사람이 읽기 쉬운 도메인 이름을 컴퓨터가 이해하는 IP 줏로 변환한다.

- 사용자 요청: 사용자가 브라우저에 도메인 이름을 입력
- 리졸버 쿼리: 시스템은 해당 도메인의 IP 주소를 캐시에서 찾는다. 없다면, DNS 리졸버에 요청
- 루트 서버: 리졸버는 루트 서버에 쿼리를 보낸다. 루트 서버는 최상위 도메인 서버의 주소를 알려준다.
- 최상위 도메인 서버: TLD 서버는 리졸버를 해당 도메인 네임 서버로 안내한다.
- 도메인 네임 서버: 이 서버는 최종적으로 도메인의 IP 주소를 제공
- 연결 설정: IP 주소를 얻은 후 브라우저는 웹사이트 연결 시도

### 4-3. 프로토콜과 포트: 웹 통신의 규칙과 접점

- HTTP: 웹상의 모든 데이터 교환의 기반을 이루는 프로토콜이다. 상태가 없는 프로토콜로 클라이언트에서 서버로의 각 요청은 이전 상호 작용을 기억하지 않고 새로운 요청을 처리된다.
- HTTPS: HTTP의 보안을 강화한 버전으로 SSL/TLS 프로토콜을 사용한다.
  - 데이터 암호화: HTTPS는 통신 중인 정보를 암호화하여 외부 공격자나 중간자에 의한 도청이나 변조를 방지한다.
  - 데이터 무결성: 데이터가 변조되지 않고 손상되지 않은 상태로 전송되는 것을 보장한다.
  - 인증: 사용자가 서버에 연결될 때 해당 서버의 신뢰성을 확인하는 과정을 포함한다. (SSL/TLS 인증서 사용)
  - SEO 및 랭킹 향상: 많은 검색 엔진이 HTTPS를 사용하는 웹사이트에 더 높은 랭킹을 부여한다.
- 포트
  - 포트는 네트워크 내에서 서버가 특저 서비스를 제공하는 통신 지점을 식별하는 역할을 한다.
  - 서버에서 실행되는 다양한 애플리케이션 또는 서비스는 각각 다른 포트 번호를 사용해 외부 요청을 구분하고 처리한다.
  - 포트 80: HTTP 기본 포트
  - 포트 443: HTTPS 기본 포트

### 4-4. 라우팅 메커니즘: 웹에서의 경로 결정 및 데이터 전송 최적화

- 중첩 라우팅: 계층 구조가 있는 여러 페이지에 유용하다. Next.js는 폴더와 파일의 명명 규칙을 사용해 중첩 라우팅을 간소화한다.
- 라우트 가드: 특정 라우트를 보호하는 데 필수적이다. Next.js는 미들웨어와 경로 가로채기 기능을 제공한다.
- 지연 로딩 & 코드 분할: 필요에 따라 애플리케이션 일부를 로딩하는 데 도움을 주며 성능을 향상시킨다. Next.js에서는 동적 임포트를 사용하여 컴포넌트를 지연 로딩하고 컴파일 시 자동으로 코드 분할을 수행한다.
- 폴백 라우트 & 페이지 미존재 라우트: 정의되지 않은 라우트를 처리하고 사용자가 길을 잃었을 때 안내하는 데 필수적이다. Next.js에서는 폴백하도록 default.js와 미존재 페이지를 not-found.js 파일을 생성하여 관리할 수 있다.
- 쿼리 매개 변수와 검색 최적화: URL의 쿼리 매개 변수를 사용하여 사용자의 검색 조건이나 선택 사항을 관리한다. 필터링이나 정렬 등 기능에 유용하다.
- 클라이언트 사이드 라우팅: 사용자 인터페이스의 일부만 변경될 떄 전체 페이지를 다시 로드하지 않고 클라이언트 사이드 라우팅을 사용할 수 있다.
- SEO 최적화: 라우팅 전략을 구성할 떄 검색 엔진의 최적화를 고려하는 것이 중요하다. 의미 있는 URL, 적절한 메타 태그와 제목, 적절한 HTTP 상태 코드 반환 등이 검색 엔진의 웹사이트 인덱싱에 긍정적인 영향을 미친다.
- 리다이렉트 및 URL 리라이트: 특정 경로에 대한 요청을 다른 경로로 리다이렉트하거나 URL을 리라이트하는 것은 효과적인 라우팅 전략의 일부이다.
- 국제화 및 지역화 지원: 다국어를 지원하고자 URL 경로에 언어 코드를 포함하거나 지역별 콘텐츠를 제공하는 라우팅 전략을 구현할 수 있다.

## 5. 인프라 구조: 웹 서버, 엣지, CDN

### 5-1. 웹 서버의 역할
