# 01장. 마이크로서비스 소개

마이크로서비스는 IT 시스템 아키텍처 접근 방식 중 하나로, 비즈니스 요구사항을 구현한 하나의 애플리케이션을 느슥하게 연결된 여러 애플리케이션으로 쪼개는 것을 말한다. 마이크로서비스는 하나의 비즈니스 영역만 구현하기 때문에 소스 코드 규모가 상대적으로 적어 이해하기 쉬우며, 코드의 품질을 유지하기 쉽다.  

스프링 클라우드는 서비스 레지스트리와 컨피규레이션 서버, 서킷 브레이커, 클라우드 버스, OAuth2 패턴, API 게이트웨이와 같은 마이크로서비스 기반 아키텍처에서 사용되는 모든 검증된 패턴을 구현한다. 또, 강력한 커뮤니티를 기반으로 새로운 기능을 자주 내놓으며, 문서화가 잘되어 있어 수 많은 예제를 쉽게 찾을 수 있다.  

<br/>

## 마이크로서비스 아키텍처 배우기

전체 시스템의 데이터에 대한 일관성을 보장해주는 뱅킹시스템이 필요하다고 가정한다.  

 - `모놀리식 애플리케이션`
```
클라이언트(API) -> 제품 객체, 계정 객체, 고객 객체, 이체 객체 -> DB

고객 객체는 활성화된 고객의 목록을 저장하고 조회한다.
모든 고객은 계정 객체에 의해 운영되는 하나 이상의 계정을 가질 수 있다.
이체 객체는 시스템 내 계정 간의 자금 이체를 담당한다.
제품 객체는 고객에게 할당된 예금이나 신용과 같은 정보의 저장을 담당한다.
```

 - `마이크로서비스 애플리케이션`
    - 일관성은 더 이상 가장 중요한 요구사항도 아니고 의무도 아니다. 또한, 모놀리식 애플리케이션은 전체 시스템을 다시 배포해야 하는 개발 방식이다. 다시 말하면 새로운 모듈과 기능을 쉽게 확장할 수 있어야한다.
    - 모놀리식 애플리케이션은 각각 전용 데이터베이스를 가진 4개의 마이크로서비스로 분리한다. 데이터베이스는 RDBMS 일수도 있고, NoSQL DB 일수도 있다.
    - 이 시스템은 독립해서 빌드하고 시스템 내부에서 다른 서비스와 통신하는지 알 필요가 없는 외부의 API 클라이언트에게는 시스템의 복잡도를 숨긴다. 게이트웨이는 클라이언트의 모든 요청을 다양한 API 종단점으로 동적으로 전달한다.
    - API 게이트웨이는 특정 서비스 호출을 숨기거나 동적 라우팅 기능을 제공하는 것 뿐만 아니라, API 게이트웨이는 시스템으로의 진입점으로 중요한 데이터 추적, 요청 메트릭 수집, 통계를 내기 위한 좋은 장소로 활용될 수 있다. 애플리케이션내에 사용할 부가정보를 삽입하기 위해 요청 및 응답 헤더를 조작할 수도 있다.
```
클라이언트 -> 게이트웨이 API -> 제품 서비스 -> DB
클라이언트 -> 게이트웨이 API -> 계정 서비스 -> DB
클라이언트 -> 게이트웨이 API -> 고객 서비스 -> DB
클라이언트 -> 게이트웨이 API -> 이체 서비스 -> DB
```

<br/>

## 서비스 디스커버리의 필요성 이해하기

서비스 디스커버리는 네트워크 상에서 서비스를 자동으로 찾아내는 프로세스를 말합니다. 이는 컴퓨터 네트워크에서 서비스나 리소스를 찾아내는 데 사용되는 기술이며, 클라이언트 애플리케이션이 특정 서비스를 찾고 사용할 수 있도록 도와줍니다. 서비스 디스커버리는 분산 시스템이나 서비스 지향 아키텍처 (SOA)와 같은 환경에서 특히 중요하게 사용됩니다.  

일반적으로 서비스 디스커버리는 DNS(Service Discovery)나 특별한 서비스 디스커버리 프로토콜을 통해 이루어집니다. 예를 들면, Netflix에서는 Eureka라는 서비스 디스커버리 툴을 사용하여 여러 마이크로서비스 간의 통신을 관리합니다.  
 - 자동 검색 및 등록: 서비스가 네트워크에 등록되면, 다른 서비스나 클라이언트 애플리케이션이 이를 검색할 수 있습니다. 이 과정은 자동으로 이루어집니다.
 - 다양한 프로토콜 지원: 서비스 디스커버리는 다양한 프로토콜과 표준을 지원하여 여러 종류의 서비스와 통합될 수 있습니다.
 - 유연성: 시스템이나 서비스의 변경이나 추가가 있을 때도 자동으로 새로운 서비스를 발견하고 적용할 수 있어야 합니다.
 - 동적인 환경 대응: 서비스의 상태가 동적으로 변할 수 있으므로, 서비스 디스커버리는 이러한 동적인 환경에 적응할 수 있어야 합니다.
 - 보안 및 권한 관리: 서비스 디스커버리 시스템은 보안 및 권한 관리 기능을 지원하여 인가된 사용자만이 특정 서비스에 접근할 수 있도록 보장합니다.

<br/>

## 서비스 간 통신

시스템의 신뢰성 보장을 위해서는 각 서비스가 하나의 인스턴스로만 운영되게 하면 안 된다. 대부분 하나의 인스턴스가 실패할 경우를 대비해 최소 두 개의 인스턴스를 실행하는 것을 목표로 한다.  

같은 서비스의 여러 인스턴스는 들어오는 요청에 대해 부하 분산을 적용해야 한다. 부하 분산기는 API 게이트웨이에 내장되어 있으며, 디스커버리 서버에 등록된 인스턴스 목록을 가져오고, 트래픽을 50/50으로 해서 모든 실행 중인 인스턴스에 분배하는 라운드 로빈 규칙을 적용한다.  

<br/>

## 장애와 서킷 브레이커

서비스 디스커버리, API 게이트웨이, 컨피규레이션 서버와 같안 메커니즘은 신뢰성이 높고 효율적인 시스템을 구성하도록 도와주는 요소이다. 그러나 시스템 아키텍처를 설계할 때 이러한 다양한 측면을 고려하더라도 항상 장애에 대해서 대비해야 한다.  

대부분 장애의 발생 원인은 네트워크 또는 데이터베이스의 문제와 같이 관리의 범위를 벗어난다. 이러한 에러는 하나의 요청이 많은 후속 호출에서 처리되는 마이크로서비스 기반의 시스템에서 특히 심각할 수 있다.  

가장 좋은 방법은 응답을 기다릴 대 네트워크 타임아웃을 활용하는 것이다. 한 서비스의 성능에 문제가 있으면 다른 서비스에 영향을 최소화하도록 노력해야 한다. 장시간 응답을 기다려서 쓰레드를 점유하게 하는 대신 에러 응답을 보내는 것이 낫다.  

네트워크 타임아웃 문제에 대한 해결책으로 서킷 브레이커 패턴이 될 수 있다. 서킷 브레이커는 성공 및 실패 요청의 횟수를 카운트하며, 에러의 비율이 가정된 임계치를 넘으면 차단이 발생하고 이후의 시도는 즉시 실패한다. 지정된 기간이 지난 후 API 클라이언트는 요청을 다시 시작하고 성공하면 서킷이 닫혀 정상화된다. 서비스마다 사용할 수 있는 다수의 인스턴스가 있고 그중 한 인스턴스가 다른 것보다 느리게 동작한다면 부하 분산 처리 시 그 인스턴스를 무시된다.  

두 번째로 네트워크 분리 장애에 자주 사용되는 메커니즘은 폴백이 있다. 이것은 요청이 실패했을 때 수행되는 로직으로 예를 들어, 서비스가 캐싱된 데이터나 기본값, 빈 결과 목록을 반환할 수 있는데, 이것보다는 에러 코드를 전파하는 것이 좋을 수 있다.  

