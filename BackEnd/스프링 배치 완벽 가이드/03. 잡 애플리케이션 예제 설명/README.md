# 03장. 잡 애플리케이션 예제 설명

시나리오는 은행 거래 명세서에 대해서 일반적인 배치 처리 예제이다.  
매일 밤 수행되는 배치 처리는 지난 달 거래 정볼르 사용해 거래명세서를 생성한다.  
기존 계좌에 거래 내역을 적용한 후 계좌별로 거래명세서를 생성한다.  
 - 입력 및 출력 방식: 은행거래명세서 잡은 일반적인 텍스트 파일인 플랫 파일과 데이터베이스에서 입력을 받는다. 또한, 플랫 파일과 데이터베이스에 출력한다.
 - 오류 처리: 거래명세서 생성 처리 예제는 로깅, 오류가 있는 레코드 건너뛰기, 로직 수행 중 오류 발생 시 해당 로직 재시도하기 등 다양한 시노리오를 다룬다.
 - 확장성: 스프링 배치의 확장성 관련 기능을 사용해 수백만 명의 고객 정보를 처리할 수 있도록 배치 처리 튜닝 방법을 다룬다.

<br/>

## 사용자 스토리로 요구 사항 포착하기

사용자 스토리는 사용자가 원하는 애플리케이션의 기능을 기록하는 것으로, 사용자가 시스템과 상호작용하는 방법을 개발 팀에 전달하고 해당 상호작용의 테스트 가능한 결과를 기록하는 데 목적이 있다.  

 - 제목
    - 제목은 스토리의 내용과 관련된 단순하고 간결한 설명이어야 한다.
    - ex) "거래 파일 내 정보를 적재한다.", "인쇄 파일을 생성한다."
 - 내러티브
    - 내러티브는 사용자 스토리로 문서화하려는 상호작용을 사용자 관점에서 간단히 설명한 것이다.
    - ex) "Y 상황에서, X가 무언가를 수행하고, 어떤 다른 일이 발생한다."
 - 인수 기준
    - 인수 기준은 스토리의 완료 여부를 판단하는 데 사용할 수 있는 테스트 가능한 요구 사항이다.
    - 주관적인 요구 사항이 아니라 "네, 그렇습니다." 또는 "아니오, 그렇지 않습니다." 라고 말할 수 있는 객관적인 항목이어야 한다.
```
＃ 제목
텔레비전 켜기

＃ 내러티브
사용자는 텔레비전, 수신기, 케이블 박스를 끈 상태에서 범용 리모컨의 전원 버튼을 누를 수 있다.
그러면 리모컨은 텔레비전, 수신기, 케이블 박스의 전원을 켜고 텔레비전 쇼를 보도록 구성한다.

＃ 인수 기준
 - 범용 리모컨에 전원 버튼이 있다.
 - 사용자가 전원 버튼을 누르면 다음과 같이 동작한다.
  1. 텔레비전 전원이 켜진다.
  2. AV 수신기 전원이 켜진다.
  3. 케이블 박스 전원이 켜진다.
  4. 케이블 박스는 187 채널로 설정될 것이다.
  5. AV 수신기는 SAT 입력으로 설정될 것이다.
  6. TV는 비디오 1 입력으로 설정될 것이다.
```

<br/>

## 테스트 주도 개발로 설계하기

TDD를 사용한다면 개발자는 실패하는 테스트를 먼저 작성한 이후에 코드를 구현해 테스트를 통과시킨다.  
TDD는 개발자들이 코드를 작성하기 전에 무엇을 코드화하려고 하는지 생각하도록 설계되었으며, 생산성을 높이고 디버거를 적게 사용하며 더 깨끗한 코드를 만들 수 있다.  
TDD의 장점은 테스트가 실행 가능한 문서 역할을 한다는 점인데, 자동화된 테스트는 지속적인 코드 유지 보수 활동으로 항상 최신화된다. 코드 조각이 어떻게 동작하는지 이해할려면 전체적인 시나리오 아래에서 코드를 개발한 개발자의 의도에 맞게 작성된 단위 테스트를 살펴보면 된다.  

<br/>

## 버전 관리 시스템 사용하기

버전 관리 시스템을 사용하면 변경한 코드가 잘 작동하면 새 버전을 커밋하고 그렇지 않다면 아무 피해 없이 이전 버전으로 롤백할 수 있다.  

<br/>

## 은행 거래명세서 잡의 요구 사항 이해하기

 - 배치 처리 기능
    - 제공된 입력 파일을 기반으로 고객 정보 갱신하기
        - 고객 정보가 담긴 고객 플랫 파일을 잡에 제공한다.
        - 배치 잡은 이 파일을 읽어서 DB의 기존 고객 데이터를 갱신한다.
    - 데이터베이스에 저장된 모든 고객의 거래 정보 가져오기
        - 거래 정보 데이터는 XML 파일 형태로 제공되며, 기존에 사용하던 DB에 추가로 저장한다.
    - 계좌 잔액으로 계좌 정보 갱신하기
        - 이 잔액 정보를 사용하면 현재 잔액을 알고 싶을 때 모든 거래를 처음부터 다시 계산할 필요가 없다.
    - 지난 한 달동안의 은행 계좌 파일 인쇄하기
        - 모든 DB 갱신이 완료되면 고객 정보, 거래 목록, 계좌의 요약 정보로 이루어진 인쇄 파일을 추출한다.

 - 데이터 모델(ERD)
    - Customer: 고객별로 고객 이름 및 연락처 정보를 비롯한 모든 고객 정보 포함
    - Account: 모든 고객의 계좌 정보 저장 (계좌번호, 현재 잔액)
    - CustomerAccount: 조인 테이블로 하나의 계좌에 많은 고객이 연관될 수 있고, 한 명의 고객도 많은 계좌를 가질 수 있다. (다대다 관계)
    - Transaction: 계좌에서 발생한 모든 거래 정보 저장
```
# CUSTOMER
 - CUSTOMER_ID
 - MIDDLE_NAME
 - LAST_NAME
 - SSN
 - EMAIL_ADDRESS
 - HOME_PHONE
 - CELL_PHONE
 - WORK_PHONE
 - NOTIFICATION_PREF

# CUSTOMER_ACCOUNT
 - CUSTOMER_CUSTOMER_ID
 - ACCOUNT_ACCOUNT_ID

# ACCOUNT
 - ACCOUNT_ID
 - BALANCE
 - LAST_STATEMENT_DATE

# TRANSACTION
 - TRANSACTION_ID
 - ACCOUNT_ACCOUNT_ID
 - CREDIT
 - DEBIT
 - TIMESTAMP
```

<br/>

## 배치 잡 설계하기

 - `고객 데이터 가져오기`
    - 플랫 파일에 포함된 여러 종류의 레코드 유형 데이터를 가져온다.
    - 데이터를 읽을 수 있다면, 쓰기 처리할 때 오류를 최소화하도록 ItemProcessor를 사용해 데이터 유효성을 검증한다.
    - 그런 다음, ItemWriter 구현체를 사용해 레코드 유형에 따라 적절하게 데이터를 갱신한다.

 - `거래 정보 데이터 가져오기`
    - 고객 데이터를 가져온 후에는 거래 데이터를 가져온다.
    - XML을 읽은 뒤 데이터베이스 기록하는 구현체를 사용한다.

 - `현재 잔액 계산하기`
    - 거래 데이터를 가져온 뒤에 계좌 테이블의 잔액을 갱신한다.
    - 잔액은 온라인 계좌 서비스를 위해 미리 계산해 갱신하며, 갱신된 잔액은 거래명세서 생성 시에도 사용한다.
    - 이를 위해 드라이빙 쿼리 패턴으로 각 계좌 내 거래 레코드를 순서대로 가져와서 해당 거래 레코드가 현재 잔액에 미치는 영향을 계산하고, 계좌 테이블의 잔액을 갱신한다.

 - `월별 고객 거래명세서 생성하기`
    - 고객의 거래명세서를 포함하는 인쇄 파일을 계좌당 하나씩 생성한다.
    - ItemReader를 사용해 DB에서 고객 데이터를 가져온다. 
    - 이후, ItemProcessor로 각 거래명세서 작성에 필요한 모든 데이터를 추가한다.
    - ItemWriter는 필요한 모든 데이터 추가가 완료된 아이템을 파일에 쓴다.
