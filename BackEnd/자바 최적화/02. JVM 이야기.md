# JVM 이야기

자바는 청므부터 개발자가 플랫폼ㅇ을 저수준에 대해서 다 알 필요가 없도록 설계하였다. 성능에 관심 있는 개발자라면 기본적인 JVM 기술 스택의 구조를 이해해야 한다.

## 1. 인터프리팅과 클래스로딩

자바 가상 머신을 규정한 명세서에 따르면 JVM은 스택 기반의 해석 머신이다. 레지스터는 없지만 일부 결과를 실행 스택에 보관하며, 이 스택의 맨 위에 쌓인 값을 가져와 계산한다. JVM 인터프리터(해석기)의 기본 로직은, 평가 스택을 이용해 중간값들을 담아두고 가장 마지막에 실행된 명령어와 독립적으로 프로그램을 구성하는 옵코드를 하나씩 순서대로 처리하는 'while 루프 안의 switch문'이다.

자바 프로세스가 새로 초기화되면 사슬처럼 줄지어 연결된 클래스로더가 차례대로 작동한다. 제일 먼저 부트스트랩 클래스가 자바 런타임 코어 클래스를 로드한다. 런타임 코어 클래스는 JDK 8 이전까지 rt.jar 파일에서 가져왔지만, JDK 9 이후부터는 런타임이 모듈화되고 클래스로딩 개념 자체가 많이 달라졌다. 부트스트랩 클래스로더의 주임무는 다른 클래스로더가 나머지 시스템에 필요한 클래스를 로드할 수 있게 최소한의 필수 클래스(ex: java.lang.Object, Class, Classload)만 로드하는 것이다.

다음을 확장 클래스로더가 생기며, 부트스트랩 클래스로더를 자기 부모로 설정하고 필요할 떄 클래스로딩 작업을 부모에게 넘긴다. 확장 클래스로더를 이용하면 특정 OS나 플랫폼에 네이티브 코드를 제공하고 기본 환경을 오버라이드 할 수 있다. JDK 8에서 탑재된 자바스크립트 런타임 내시혼을 바로 확장 클래스로더가 로드한다.

끝으로 애플리케이션 클래스로더가 생성되고 지정된 클래스패스에 위치한 유저 클래스를 로드한다.

자바는 프로그램 실행 중 처음보는 새 클래스를 디펜던시(의존체)에 로드한다. 클래스를 찾기 못한 클래스로더는 기본적으로 자신의 부모 클래스로더에게 대신 룩업을 넘긴다. 이렇게 부모의 부모로 거슬러 올라가 결국 부트스트랩도 룩업하지 못하면 ClassNotFoundException 예외가 발생한다.

## 2. 바이트코드 실행

자바 소스 코드는 실행되기까지 많은 변환 과정을 거친다.

첫 단계는 자바 컴파일러(javac)를 이용해 컴파일하는 것으로, 보통 전체 빌드 프로세스의 한 부분으로 수행한다. javac가 하는 일은 자바 소스 코드를 바이트코드로 가득 찬 .class 파일로 바꾸는 것이다. 바이트코드는 특정 컴퓨터 아키텍처에 특정하지 않은, 중간 표현형으로 컴퓨터 아키텍처의 지배를 받지 않으므로 이식성이 좋아 개발을 마친 소프트웨어는 JVM 지원 플랫폼 어디서든 실행할 수 있고 자바 언어에 대해서도 추상화되어 있다.

- 클래스 파일 해부도
  - **매직 넘버**
    - 0xCAFEBABE
    - 모든 클래스 파일은 이 파일이 클래스 파일임을 나타내는 4바이트 16진수(0xCAFEBABE라는 매직 넘버)로 시작한다.
  - **클래스 파일 포맷 버전**
    - 클래스 파일의 메이저/마이너 버전
    - 메이저/마이너 버전은 클래스로더의 호환성 보장을 위해 검사하고 호환되지 않는 버전의 클래스 파일을 만나면 런타임에 UnsupportedClassVersionError 예외기 발생한다.
  - **상수 풀**
    - 클래스 상수들이 모여 있는 위치
    - 코드 곳곳에 등장하는 상숫값이 있다. JVM은 코드를 실행할 때 런타임에 배치된 메모리 대신, 이 상수 풀 테이블을 찾아보고 필요한 값을 참조한다.
  - **액세스 플래그**
    - 추상 클래스, 정적 클래스 등 클래스 종류를 표시
    - 클래스에 적용한 수정자를 결정한다. 플래그 첫 부분은 일반 프로퍼티로 public 클래스인지, 그다음은 상속이 금지된 Final 클래스인지를 나타낸다. 또 이 클래스 파일이 인터페이스인지, 추상 클래스인지도 액세스 플래그로 표시한다.
    - 플래그 끝부분은 클래스 파일이 소스 코드에 없는 합성 클래스인지, 애너테이션 타입인지, 이늄인지를 각각 나타낸다.
  - **this 클래스**
    - 현재 클래스명
  - **슈퍼 클래스**
    - 슈퍼클래스(부모클래스)명
  - **인터페이스**
    - 클래스가 구현한 모든 인터페이스
  - **필드**
    - 클래스에 들어 있는 모든 필드
  - **메서드**
    - 클래스에 들어 있는 모든 메서드
  - **속성**
    - 클래스가 지닌 모든 속성(소스 파일명 등)

## 3. 핫스팟 입문

JVM HotSpot은 자바 가상 머신(JVM)의 구현체 중 하나로, Oracle과 OpenJDK에서 사용되는 가장 널리 사용되는 JVM입니다. "HotSpot"이라는 이름은 프로그램 실행 중 빈번하게 사용되는 코드(핫스팟)를 탐지하고, 그 코드를 최적화하는 데 집중하는 실행 방식을 의미합니다.

- JIT 컴파일러 (Just-In-Time 컴파일)
  - HotSpot JVM은 처음에는 바이트코드를 인터프리터 방식으로 실행하지만, 특정 코드가 자주 실행된다고 판단되면 JIT 컴파일러가 해당 코드를 네이티브 코드로 변환하여 성능을 크게 향상시킵니다.
  - JIT 컴파일은 런타임에 이루어지며, 컴파일된 네이티브 코드는 캐시되어 이후 호출 시 재사용됩니다. 이를 통해 반복적으로 실행되는 코드의 성능을 높일 수 있습니다.
- C1과 C2 컴파일러
  - HotSpot JVM은 두 종류의 JIT 컴파일러를 제공합니다
  - C1(클라이언트 컴파일러): 빠른 최적화가 필요할 때 사용되며, 초기 실행 성능을 높이는 데 중점을 둡니다.
  - C2(서버 컴파일러): 더 복잡한 최적화를 통해 장기적인 성능 향상을 추구하며, 서버 애플리케이션에 더 적합합니다.
- Garbage Collection (GC)
  - HotSpot JVM은 다양한 GC 알고리즘을 지원하여 메모리 관리의 최적화를 돕습니다. GC는 사용되지 않는 객체들을 메모리에서 자동으로 해제하는 작업을 의미합니다.
  - 주요 GC 알고리즘에는 Serial GC, Parallel GC, G1 GC, ZGC 등이 있으며, 각 알고리즘은 애플리케이션의 요구 사항에 맞춰 메모리 관리를 최적화합니다.
- 인터프리터와 JIT 컴파일 협력
  - HotSpot JVM은 인터프리터(해석기)와 JIT 컴파일러가 협력하여 프로그램을 실행합니다. 처음에 바이트코드를 인터프리팅하며 실행 속도가 느리지만, 핫스팟 코드가 발견되면 JIT 컴파일러가 이를 네이티브 코드로 컴파일하여 실행 속도를 빠르게 합니다.
- 핫스팟 탐지 (HotSpot Detection)
  - HotSpot JVM은 자주 호출되거나 반복 실행되는 코드 블록을 핫스팟으로 인식하여 JIT 컴파일러를 통해 최적화합니다. 이를 프로파일링이라고도 하며, 이러한 최적화를 통해 애플리케이션의 성능이 크게 향상됩니다.
- 런타임 최적화 (Runtime Optimizations)
  - HotSpot JVM은 런타임에 여러 가지 최적화 기법을 적용하여 성능을 향상시킵니다. 예를 들어 인라인화, 루프 최적화, 동적 디스패치 제거 같은 최적화 기법들이 적용됩니다.
  - 또한, Speculative Optimization(추측적 최적화)를 적용하여 특정 조건에서 성능을 최적화하지만, 그 조건이 변하면 다시 인터프리터로 돌아가거나 재컴파일할 수 있는 유연성도 제공합니다.

### 3-1. JIT 컴파일러

자바 프로그램은 바이트코드 인터프리터가 가상화한 스택머신에서 명령어를 실행하며 시작된다. CPU를 추상화한 구조로 다른 플랫폼에서도 클래스 파일을 문제없이 실행할 수 있지만, 프로그램이 성능을 최대로 내려면 네이티브 기능을 활용해 CPU에서 직접 프로그램을 실행시켜야 한다. 이를 위해 핫스팟은 프로그램 단위를 인터프리티드 바이트코드에서 네이티브 코드로 컴파일한다. 핫스팟은 인터프리티드 모드로 실행하는 동안 애플리케이션을 모니터링하면서 가장 자주 실행되는 코드 파트를 발견해 JIT 컴파일을 수행한다.

- 초기 실행시 인터프리티드 모드로 실행된다. 즉, 바이트코드를 CPU가 해석할 수 있는 코드로 번역하면서 컴퓨터에서 실행된다.
- 가장 최적의 성능을 얻기 위해서는 CPU가 바로 해석할 수 있는 네이티브 코드가 제공되어야 한다.
- JIT 컴파일은 이러한 바이트 코드(.class)를 CPU가 해석할 수 있는 네이티브 코드로 컴파일한다.
- 자주 실행되는 코드를 컴파일하여 성능이 개선된다.

## 4. JVM 메모리 관리

자바는 가비지 수집(Garbage Collection)이라는 프로세스를 이용해 힙 메모리를 자동 관리하는 방식을 사용한다. 가비지 수집이란 JVM이 더 많은 메모리를 할당해야 할 떄 불필요한 메모리를 회수하거나 재사용하는 불확정적 프로세스이다.

GC를 만드는 일은 결코 간단하지 않았고 자바 역사를 통틀어 온갖 가비지 수집 알고리즘이 개발/응용되었다. **GC가 실행되면 그동안 다른 애플리케이션은 모두 중단되고 하던 일은 멈춰야 한다. 이주 중단 시간은 대개 아주 짧지만, 애플리케이션 부하가 늘수록 이 시간도 무시할 수 없다.**

## 5. 스레딩과 자바 메모리 모델(JMM)

- 자바의 멀티스레드 방식 기본 설계 원칙
  - 자바 프로세스의 모든 스레드는 가비지 수집되는 하나의 공용 힙을 가진다.
  - 한 스레드가 생성한 객체는 그 객체를 참조하는 다른 스레드가 액세스할 수 있따.
  - 기본적으로 객체는 변경 가능하다. 즉, 객체 필드에 할당한 값은 프로그래머가 애써 Final 키워드로 불변 표시하지 않는 한 바뀔 수 있다.

## 6. JVM 구현체 종류

- **OpenJDK**: 자바 기준 구현체를 제공하는 특별한 오픈 소스(GPL) 프로젝트로 오라클이 직접 프로젝트를 주관/지원하며 자바 릴리즈 기준을 발표한다.
- **오라클 자바(Oracle)**: OpenJDK가 기반이지만 오라클 상용 라이선스로 재라이선스를 받았다. 오라클 자바에 변경된 내용은 거의 전부 OpenJDK 공개 저장소에 커밋된다.
- **줄루(Zulu)**: 줄루는 아줄 시스템이 제작한, 자바 풀 인증을 받은 무료(GPL) OpenJDK 구현체로 상용 라이선스 문제로 제약받을 일 없이 자유롭게 재배포할 수 있다.
- **아이스티(IcedTea)**: 아이스티는 레드햇의 작품으로 풀 인증을 받았고 재배포 가능하다.
- **징(Zing)**: 징은 아줄 시스템이 제작한 고성능 상용 JVM이다. 자바 풀 인증을 받았고 64비트 리눅스에서만 작동한다. 대용량 힙 메모리(수십 ~ 수백 GB)와 멀티 CPU 서버급 시스템을 위해 설계된 제품이다.
- **J9**: IBM이 만든 J9는 상용 JVM으로 출발했다가 중간에 오픈 소스로 변경되었다. 지금은 이클립스 OMR 프로젝트 기반으로 제작되며 IBM 상용 제품의 근간을 이루고 있다.
- **애비안(Avian)**: 애비안은 100% 자바 인증을 받은 구현체가 아니므로 제품으로 쓰기에 완전한 솔루션은 아니지만, JVM의 세부 작동 원리가 궁금한 개발제에게 훌륭한 학습 도구 역할을 할 수 있다.

### 6-1. JVM 라이선스

오라클 자바의 기반은 OpenJDK 코드 베이스이지만 오픈 소스가 아닌, 상용 제품이다. 그래서 오라클은 모든 OpenJDK 컨트리뷰터들이 OpenJDK의 GPL 라이선스와 오라클사의 상용 라이선스, 이중 라이선스에 동의한다는 서명을 받아냈다.

## 7. JVM 모니터링과 툴링

JVM은 성숙한 실행 플랫폼으로 실행 중인 애플리케이션을 인스트루먼테이션, 모니터링, 관측하는 다양한 기술을 제공한다.

- 자바 관리 확장(JMX)
  - JMX는 JVM과 그 위에서 동작하는 애플리케이션을 제어하고 모니터링하는 강력한 범용 툴이다. 여느 클라이언트 애플리케이션처럼 메서드를 호출하고 매개변수를 바꿀 수 있다.
- 자바 에이전트
  - 자바 에이전트는 자바 언어로 작성된 툴 컴포넌트로, java.lang.instrument 인터페이스로 메서드 바이트코드를 조작한다.
  - `-javaagent:{에이전트 JAR 파일 경로}={옵션}`
  - 에이전트 JAR 파일에서 매니페스트는 필수이다. 또 Premain-Class 속성에 에이전트 클래스명을 반드시 지정해야 한다. 이 클래스는 자바 에이전트의 등록 후크 역할을 수행하는 public static main() 메서드를 구현해야 한다.
- JVM 툴 인터페이스 (JVMTI)
  - 자바 인스트루먼테이션 API로 부족하면 JVMTI를 대신 사용할 수 있다. JVMTI는 JVM의 네이티브 인터페이스로 JVMTI를 사용할 떄 에이전트는 필히 C/C++ 같은 네이티브 컴파일 언어로 작성해야 한다.
  - 네이티브 에이전트가 JVM 이벤트를 모니터링하며 알림을 받을 수 있도록 만든 통신 인터페이스이다.
  - `-agentlib:{에이전트 라이브러리명}={옵션}` 혹은 `-agentpath:{에이전트 경로}={옵션}`
- 서비서빌리티 에이전트(SA)
  - SA는 자바 객체, 핫스팟 자료 구조 모두 표출 가능한 API와 ㅌ툴을 모아놓은 것으로 SA를 이용하면 대상 JVM에서 코드를 실행할 필요가 없다. 핫스팟 SA는 심볼 룩업 같은 기본형을 이용하거나 프로세스 메모리를 읽는 방식으로 디버깅한다.
  - SA는 코어 파일 및 아직 생생한 자바 프로세스까지 디버깅할 수 있다.

### 7-1. VisualVM

javac, java 등의 잘 알려진 바이너리뿐만 앙니라 JDK에는 유용한 툴이 많다. VisualVM은 초기 자바 버전에 있다가 이제는 더 이상 안쓰는 jconsole을 대체하는 툴이다.

- VisualVM을 처음 시작하면 자신이 실행되는 머신을 보정하는 과정을 거치므로 성능 보정에 영향을 줄 만한 다른 애플리케이션은 닫는게 좋다.
- VisualVM은 JVM 어태치 메커니즘을 이용해 실행 프로세스를 실시간 모니터링 한다.
  - 원격 프로세스에 연결하려면 원격지로부터 인바운드 접속이 허용돼야 한다. 표준 자바 프로세스에서 이 말은 원격 호스트에서 jstatd이 실행되고 있어야 한다는 것이다.
