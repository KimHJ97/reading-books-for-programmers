# 하드웨어와 운영체제

## 1. 메모리

무어의 법칙에 따라 개수가 급증한 트랜지스터는 처음엔 클록 속도를 높이는 데 쓰였다. 클록 속도가 증가하면 초당 더 많은 명령어를 처리할 수 있따. 프로세서 속도는 놀라우리만치 빨라졌으며, 4.77MHz로 작동했던 최초의 IBM PC 칩에 비하면 요즘 2GHz가 넘는 프로세서는 수백 배 더 빨라진 것이다.

클록 속도가 증가하면서 다른 문제가 생겨났다. 칩이 빨라질수록 데이터도 더 빨리 움직여야 하는데, 시간이 갈수록 프로세서 코어의 데이터 수요를 메인 메모리가 맞추기 어려워졌다.

### 1-1. 메모리 캐시

때문에, CPU 캐시가 고안되었다. CPU 캐시는 CPU에 있는 메모리 영역으로 레지스터보다는 느리지만 메인 메모리보다는 훨씬 빠르다. 자주 액세스하는 메모리 위치는 CPU가 메인 메모리를 재참조하지 않게 사본을 떠서 CPU 캐시에 보관하자는 아이디어이다.

요즘 CPU에는 액세스 빈도가 높은 캐시일수록 프로세서 코어와 더 가까이 위치하는 식으로 여러 캐시 계층이 존재한다. CPU와 가장 가까운 캐시가 L1, 그 다음 캐시가 L2 식으로 명명된다. 프로세서 아키텍처에 따라 캐시 개수 및 설정 상태는 제각각이지만, 일반적으로 각 실행 코어에 전용 프라이빗 캐시 L1, L2를 두고, 일부 또는 전체 코어가 공유하는 L3 캐시를 둔다.

CPU 코어마다 전용 L1, L2 캐시가 있고 모든 코어가 공유하는 L3 캐시가 있다. 메인 메모리는 노스브리지 컴포넌트를 거쳐 액세스하고 이 버스를 관통함으로써 메인 메모리 액세스 시간이 확 줄어든다.

이렇게 캐시 아키텍처를 추가한 덕분에 프로세서 처리율은 현저히 개선됐지만, 메모리에 있는 데이터를 어떻게 캐시로 가져오고 캐시한 데이터를 어떻게 메모리에 다시 써야 할지 결정해야 했다. 이러한 문제는 보통 캐시 일관성 프로토콜이라는 방식으로 해결한다.

### 1-2. MESI 프로토콜

MESI 프로토콜은 캐시 라인 상태를 네 가지로 정의한다.

- Modified(수정): 데이터가 수정된 상태
- Exclusive(배타): 이 캐시에만 존재하고 메인 메모리 내용과 동일한 상태
- Shared(공유): 둘 이상의 캐시에 데이터가 들어 있고 메모리 내용과 동일한 상태
- Invalid(무효): 다른 플세스가 데이터를 수정하여 무효한 상태

이 프로토콜에서는 프로세서가 상태를 바꾸겠다는 의사를 브로드캐스팅한다. 공유 메모리 버스를 통해 전기 신호를 보내면 다른 프로세서가 이를 알아차린다.

프로세서가 처음 나왔을 당시에 매번 캐시 연산 결과를 바로 메모리에 기록했다. 이를 동시 기록(라이트-스루)이라고 하며, 메모리 대역폭을 너무 많이 소요하는 등 효율이 낮아 요즘은 거의 사용하지 않는다. 나중에 출시된 프로세서는 후기록(라이트-백) 방식을 선택하여 캐시 블록을 교체해도 프로세서가 변경된 캐시 블록만 메모리에 기록하므로 메인 메모리로 되돌아가는 트래픽이 뚝 떨어진다.

```java
public class Caching {
    private final int ARR_SIZE = 2 * 1024 * 1024;
    private final int[] testData = new int[ARR_SIZE];

    private void run() {
        System.err.println("Start: " + System.currentTimeMillis());
        for (int i = 0; i < 15_000; i++) {
            touchEveryLine();
            touchEveryItem();
        }
        System.err.println("Warmup Finished: " + System.currentTimeMillis());
        System.err.println("Item Line");

        for (int i = 0; i < 100; i++) {
            long t0 = System.nanoTime();
            touchEveryLine();
            long t1 = System.nanoTime();
            touchEveryItem();
            long t2 = System.nanoTime();
            long elItem = t2 - t1;
            long elLine = t1 - t0;
            double diff = elItem - elLine;
            System.err.println(elItem + " " + elLine + " " + (100 * diff / elLine));
        }
    }

    private void touchEveryItem() {
        for (int i = 0; i < testData.length; i++)
            testData[i]++;
    }

    private void touchEveryLine() {
        for (int i = 0; i < testData.length; i += 16)
            testData[i]++;
    }
}
```

## 2. 최신 프로세서의 특성

### 2-1. 변환 색인 버퍼(TLB)

변환 색인 버퍼는 여러 캐시에서 사용되며, 가상 메모리 주소를 물리 메모리 주소로 매핑하는 페이지 테이블의 캐시 역할을 수행한다. 덕분에 가상 주소를 참조해 물리 주소에 액세스하는 빈번한 작업 속도가 매우 빨라졌다.

TLB가 없으면 L1 캐시에 페이지 테이블이 있어도 가상 주소 룩업에 16사이클이나 걸리기 떄문에 성능이 제대로 나오지 않는다.

### 2-2. 분기 예측과 추측 실행

분기 예측은 최신 프로세서 기법 중 하나로, 프로세서가 조건 분기하는 기준값을 평가하느라 대기하는 현상을 방지한다.

### 2-3. 하드웨어 메모리 모델

어떻게 하면 서로 다른 여러 CPU가 일관되게 동일한 메모리 주소를 액세스할 수 있을까? 이 질문의 해답은 하드웨어에 따라 다르지만, JIT 컴파일러인 javac와 CPU는 일반적으로 코드 실행 순서를 바꿀 수 있다. 물론 코드 실행 순서를 바꿔도 현재 스레드가 바라보는 결과는 아무런 영향이 없다는 전제가 필요하다.

## 3. 운영체제

OS의 주 임무는 여러 실행 프로세스가 공유하는 리소스 액세스를 관장하는 일이다. 모든 리소스는 한정되어 있고 프로세스는 저마다 리소스를 더 차지하려고 하기 때문에 리소스 양을 보고 골고루 나누어 줄 중앙 시스템이 있어야 한다. 한정된 리소스 가운데 메모리와 CPU 시간은 가장 중요한 쌍벽이 된다.

메모리 관리 유닛(MMU)을 통한 가상 주소 방식과 페이지 테이블은 메모리 액세스 제어의 핵심으로서, 한 프로세스가 소유한 메모리 영역을 다른 프로세스가 함부로 훼손하지 못하게 한다.

### 3-1. 스케줄러

프로세스 스케줄러는 CPU 액세스를 통제한다. 이때 실행 큐라는 큐를 이용한다.

스케줄러는 인터럽트에 응답하고 CPU 코어 액세스를 관리한다.

### 3-2. 컨텍스트 교환

컨텍스트 교환은 OS 스케줄러가 현재 실행 중인 스레드/태스크를 없애고 대기 중인 다른 스레드/태스크로 대체하는 프로세스이다.

유저 스레드 사이에 발생하든, 유저 모드에서 커널 모드로 바뀌면서 일어나든 컨텍스트 교환은 비싼 작업이다. 유저 공간에 있는 코드가 액세스하는 메모리 영역은 커널 코드와 거의 공유할 부분이 없기 때문에 모드가 바뀌면 명령어와 다른 캐시를 어쩔 수 없이 강제로 비워야 한다.

커널 모드로 컨텍스트가 교환되면 TLB를 비롯한 다른 캐시까지도 무효화된다. 이들 캐시는 시스템 콜 반환 시 다시 채워야 하므로 커널 모드 교환의 여파는 유저 공간으로 다시 제어권이 넘어간 후에도 당분간 이어진다.

리눅스는 이를 최대한 만회하기 위해 가상 동적 공유 객체(vDSO)라는 장치를 제공한다. vDSO는 굳이 커널 프리빌리지가 필요 없는 시스템 콜의 속도를 높이려고 쓰는 유저 공간의 메모리 영역이다. 커널 모드로 컨텍스트를 교환하지 않으므로 그만큼 속도가 빠르다.

## 4. 기본 감지 전략

애플리케이션이 잘 돌아간다는 것은 CPU 사용량, 메모리, 네트워크, I/O 대역폭 등 시스템 리소스를 효율적으로 잘 이용하고 있다는 뜻이다. 성능 진단의 첫 단추는 어느 리소스가 한계에 다다랐는지 밝히는 일이다.

### 4-1. CPU 사용률

CPU 사용률은 애플리케이션 성능을 나타내는 핵심 지표이다.

성능 엔지니어라면 기본 툴 두 가지(vmstat, iostat) 정도는 사용할 줄 알아야 한다. 유닉스 계열 OS 명령줄에 툴 명령어를 실행하면 각각 현재 가상 메모리 및 I/O 서브시스템 상태에 관한 유용한 데이터를 신속히 제공한다.

- **vmstat**
  - vmstat는 서버 성능을 진단하고 메모리 사용, CPU 로드, 스왑 사용량 등을 분석하는 데 유용한 도구로, 시스템 튜닝과 문제 해결에 중요한 역할을 합니다.
  - vmstat는 Linux 및 Unix 기반 운영 체제에서 시스템 성능을 모니터링하기 위한 유틸리티입니다. vmstat는 CPU, 메모리, 페이징, 블록 입출력, 시스템 프로세스, 그리고 컨텍스트 스위칭에 대한 다양한 통계를 실시간으로 제공하여 시스템 상태를 분석하고 성능 문제를 진단하는 데 유용합니다.
  - procs (프로세스):
    - r: 실행 대기 중인 프로세스 수 (러닝 큐의 크기)
    - b: 대기 중인 블록된 프로세스 수 (입출력 대기 등으로 인해)
  - memory (메모리):
    - swpd: 스왑 메모리 사용량 (킬로바이트 단위)
    - free: 사용 가능한 물리적 메모리 양 (킬로바이트 단위)
    - buff: 버퍼 캐시로 사용되는 메모리 양 (킬로바이트 단위)
    - cache: 페이지 캐시로 사용되는 메모리 양 (킬로바이트 단위)
  - swap (스왑 메모리):
    - si: 디스크로부터 스왑 메모리로 읽힌 데이터 양 (킬로바이트 단위)
    - so: 스왑 메모리로부터 디스크로 기록된 데이터 양 (킬로바이트 단위)
  - io (입출력):
    - bi: 블록 장치로부터 읽힌 데이터 양 (킬로바이트 단위)
    - bo: 블록 장치로 기록된 데이터 양 (킬로바이트 단위)
  - system (시스템 통계):
    - in: 초당 인터럽트 수
    - cs: 초당 컨텍스트 스위칭 수
  - cpu (CPU 사용률):
    - us: 사용자 모드에서 소비된 CPU 시간 비율
    - sy: 시스템 모드에서 소비된 CPU 시간 비율
    - id: 유휴 상태의 CPU 비율
    - wa: I/O 대기 중인 CPU 시간 비율
    - st: 하이퍼바이저가 시스템에서 가져간 CPU 시간 비율

```bash
# 현재 시스템의 성능 통계를 한 번 출력합니다.
vmstat

# 2초 간격으로 실시간으로 시스템 통계를 출력합니다.
vmstat 2

# 2초 간격으로 5번 업데이트한 후 종료합니다.
vmstat 2 5
```

- **iostat**
  - iostat는 Linux 및 Unix 시스템에서 입출력(I/O) 장치 성능을 모니터링하는 도구로, CPU 사용률 및 디스크 입출력 통계를 제공하여 시스템의 저장 장치나 CPU와 관련된 성능 병목 현상을 진단하는 데 사용됩니다. 이 도구는 디스크, 파티션, 네트워크 파일 시스템 등의 장치별로 입출력 활동을 모니터링할 수 있어, 특정 장치나 시스템 전체의 입출력 성능을 분석하는 데 유용합니다.
  - iostat는 시스템의 입출력 성능을 모니터링하고 병목 현상을 파악하는 데 매우 유용한 도구로, 특히 CPU가 I/O 대기로 인해 유휴 상태가 되는지, 디스크나 네트워크 파일 시스템의 과부하 문제를 해결해야 하는지 등을 분석하는 데 중요한 역할을 합니다.
  - CPU Usage (CPU 사용량):
    - CPU 사용률을 보여주는 섹션에서 다음과 같은 항목을 볼 수 있습니다:
    - %user: 사용자 모드에서 CPU가 사용된 비율.
    - %nice: 낮은 우선순위(niced) 사용자 프로세스에서 CPU가 사용된 비율.
    - %system: 시스템(커널) 모드에서 CPU가 사용된 비율.
    - %iowait: CPU가 I/O 작업을 기다리는 데 소비한 시간 비율.
    - %steal: 가상 CPU가 다른 가상 머신에서 사용되는 동안 대기한 시간 비율.
    - %idle: 유휴 상태의 CPU 비율.
  - Device Utilization (디스크 장치 사용률):
    - 디스크나 기타 블록 장치에 대한 I/O 성능을 보여주는 섹션입니다:
    - Device: 장치 이름 (예: sda, sdb).
    - tps: 초당 전송 요청 수 (I/O 작업 수).
    - kB_read/s: 초당 읽힌 데이터 양 (킬로바이트 단위).
    - kB_wrtn/s: 초당 기록된 데이터 양 (킬로바이트 단위).
    - kB_read: 프로그램 실행 이후 읽힌 총 데이터 양.
    - kB_wrtn: 프로그램 실행 이후 기록된 총 데이터 양.
    - await: I/O 작업 요청이 완료되기까지의 평균 대기 시간 (밀리초 단위).
    - svctm: I/O 요청을 처리하는 데 걸린 평균 서비스 시간 (밀리초 단위).
    - %util: 디스크가 얼마나 바쁘게 사용되었는지를 백분율로 표시한 것. 100%에 가까울수록 디스크가 과부하 상태일 가능성이 높습니다.

```bash
# CPU 및 모든 장치에 대한 기본 통계를 표시합니다.
iostat

# 2초 간격으로 CPU와 I/O 통계를 갱신합니다.
iostat 2

# sda 장치의 디스크 I/O 통계를 표시합니다.
iostat -d sda

# 디스크 통계만 출력 (CPU 통계는 제외)
iostat -d
```

### 4-2. 가비지 수집

JVM에서 GC 로깅은 거의 공짜나 다름없다. 전체 비용을 최대한 정밀하게 산정한다고 해도 주변의 랜덤한 노이즈와 확실히 구분하기 어렵다. GC 로깅은 분석용 데이터의 원천으로서도 가치가 높기 떄문에 JVM 프로레스는 예외 없이 특히 운영 환경에서는 GC 로그를 꼭 남겨야 한다.
