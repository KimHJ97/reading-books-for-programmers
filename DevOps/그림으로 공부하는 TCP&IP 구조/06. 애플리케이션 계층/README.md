# 06장. 애플리케이션 계층

트랜스포트 계층은 전송을 제어하고, 애플리케이션별로 패킷을 선별하는 것까지 담당한다.  
패킷을 받은 애플리케이션은 각 애플리케이션이 담당하여 처리한다.  

애플리케이션 계층의 프로토콜은 세션 계층, 프레젠테이션 계층, 애플리케이션 계층을 모아서 하나의 애플리케이션 프로토콜로 표준화되었다.  

<br/>

## HTTP

HTTP는 Hypertext Transfer Protocol의 약자로 원래 텍스트 파일을 다운로드하기 위한 목적의 간소한 프로토콜이었다. 하지만, 지금은 그 범위를 넘어 파일 송수신, 실시간 메시지 교환, 동영상 송출, 웹 회의 시스템 등 많은 용도로 사용된다.  

<br/>

### HTTP 버전

HTTP는 1991년에 등장한 이래 HTTP/0.9, HTTP/1.0, HTTP/1.1, HTTP/2, HTTP/3로 큰 버전 업그레이드가 있었다.  
HTTP/0.9와 HTTP/1.0은 리퀘스트마다 TCP 커넥션을 만들고 부수는 순서를 반복하였다.  

 - `HTTP/0.9(1991년)`
    - 텍스트 파일 다운로드만 가능
    - 헤더나 바디 등 메시지 포맷 규정도 존재하지 않음
 - `HTTP/1.0(1996년)`
    - RFC1945로 표준화
    - 메시지 포맷 책정
    - 다양한 파일(텍스트, 동영상, 이미지) 전송 가능
    - 다운로드, 업로드 가능
 - `HTTP/1.1(1997년)`
    - RFC2068이나 RFC2616, RFC7230 ~ 7235로 표준화
    - 파이프라인 기능 추가
        - 요청에 대한 응답을 기다리지 않고 다음 요청을 송신하는 기능
    - 킵얼라이브 기능 추가
        - 한 번 만들어진 TCP 커넥션을 재사용하여 TCP 핸드셰이크의 패킷 왕복 시간이 짧아져 처리량 증가
 - `HTTP/2(2015년)`
    - RFC7540으로 표준화(SPDY 기반)
    - 바이너리 형식으로 통신
    - 멀티플렉싱/헤더 압축/서버 푸시 추가
        - 멀티플렉싱: 1개의 TCP 커넥션 안에서 스트림이라는 가상 채널을 만들고 스트림별로 요청과 응답을 교환하게 함으로써 HoL 블로킹 문제 해소
        - HPACK: 메시지 헤더를 압축하는 기능
        - 서버 푸시: 하나의 요청에 대해 여러 응답을 반환하는 푸시 타입 기능으로 HTTP/2 서버는 클라이언트가 최초로 요청한 콘텐츠를 해석하고, 다음에 올 요청에 대한 응답을 요청이 오기 전ㅇ 보낸다.
    - 거대 웹사이트에서의 채용 확대
 - `HTTP/3(2020년)`
    - RFC9114로 표준화(QUIC 기반)
    - UDP/TLS 1.3을 사용해 성능 향상
        - TCP가 아니라 UDP를 사용하여 3 Way HandShake에 걸리는 시간을 줄이고, 더 많은 HTTP 데이터를 보낼 수 있도록 한다.
        - TSL 1.3은 더욱 작은 패킷의 교환으로 SSL 핸드셰이크에 걸리는 시간을 줄이고 더 많은 HTTP 데이터를 보낼 수 있도록 한다.

<br/>

### HTTP/1.1의 메시지 포맷

HTTP에서 교환하는 정보를 HTTP 메시지라 부른다.  
HTTP 메시지에는 웹브라우저 서버에서 처리를 요청하는 __요청 메시지(Request Message)__, 서버가 웹브라우저에 처리 결과를 반환하는 __응답 메시지(Response Message)__ 2가지가 있다.  
두 메시지 모두 HTTP 메시지의 종류를 나타내는 __시작 라인(Start Line)__, 각종 제어 정보를 여러 행에 걸쳐 저장하는 __메시지 헤더(Message Header)__, 애플리케이션 데이터의 본문을 저장하는 __메시지 바디(HTTP 페이로드)__ 3가지로 구성되어 있으며, 메시지 헤더와 메시지 바디 사이에는 경계선을 나타내는 빈 행의 줄 바꿈 코드(\\r\\n)가 들어간다.  

<div align="center">
    <img src="./images/HTTP_Message_Format.png"><br/>
    <img src="./images/HTTP_Message_Format_Example.png">
    시작 라인, HTTP 헤더, 빈 줄(Blank Line), 본문(Contents)로 구성
</div>
<br/>

 - `요청 메시지 포맷`
    - 스타트 라인, 메시지 헤더(HTTP 헤더), 메시지 바디로 구성된다.
    - __스타트 라인(요청 라인)__
        - 요청 라인은 요청 종류를 나타내는 메서드(HTTP Method), 리소스 식별자를 나타내는 요청 URI, HTTP 버전을 나타내는 HTTP 버전 3가지로 구성된다.
        - ex) POST / HTTP 1.1
        - ex) GET /books HTTP/1.0
    - 메시지 헤더(HTTP 헤더)에는 요청 헤더(Request Header), 일반 헤더(Generic Header), 엔티티 헤더(Entity Header), 기타 헤더(Auxiliary Header) 4개 HTTP 헤더 중 하나로 구성된다.

<div align="center">
    <img src="./images/HTTP_Request_Message_Format.PNG">
</div>
<br/>

 - `요청 메시지 포맷`
    - 스타트 라인, 메시지 헤더(HTTP 헤더), 메시지 바디로 구성된다.
    - __스타트 라인(상태 라인)__
        - 상태 라인은 웹서버가 웹브라우저에 대해 처리 결과의 개요를 반환하는 행으로 HTTP 버전을 나타내는 HTTP 버전, 처리 결과의 개요를 3자리 숫자로 나타내는 상태 코드(State Code), 그 이유를 나타내는 원인 문장으로 구성되어 있다.
            - 1xx(Informational)
                - 100(Continue): 클라이언트는 요청을 계속할 수 있다.
                - 101(Switching Protocols): Upgrade 헤더를 사용해 프로토콜, 또는 버전을 변경한다.
            - 2xx(Success)
                - 200(OK): 정상적으로 처리 종료
            - 3xx(Redirection)
                - 301(Moved Permanently): Location 헤더를 사용해 다른 URI에 리다이렉트한다. (영구 대응)
                - 302(Found): Location 헤더를 사용해 다른 URI에 리다이렉트한다. (임시 대응)
                - 304(Not Modified): 리소스가 업데이트되지 않았다.
            - 4xx(Client Error)
                - 400(Bad Request): 요청 구분에 오류가 있다.
                - 401(Unauthorized): 인증에 실패했다.
                - 403(Forbidden): 해당 리소스에 대해 액세스가 거부되었다.
                - 404(Not Found): 해당 리소스가 존재하지 않는다.
                - 406(Not Acceptable): 대응하는 종류의 파일이 없다.
                - 412(Precondition Failed): 전체 조건을 만족하지 않는다.
            - 5xx(Server Error)
                - 503(Service Unavailable): 웹 서버 애플리케이션에 장애가 발생했다.
        - ex) HTTP/1.1 200 OK
        - ex) HTTP/1.1 403 Forbidden
    - 메시지 헤더(HTTP 헤더)에는 응답 헤더(Response Header), 일반 헤더(Generic Header), 엔티티 헤더(Entity Header), 기타 헤더(Auxiliary Header) 4개 HTTP 헤더 중 하나로 구성된다.

<div align="center">
    <img src="./images/HTTP_Response_Message_Format.PNG">
</div>
<br/>

### 다양한 HTTP 헤더

메시지 헤더는 요청 헤더, 응답 헤더, 일반 헤더, 엔티티 헤더, 기타 헤더 5 종류의 HTTP 헤더가 있다.  

Content-Encoding 헤더와 Accept-Encoding 헤더는 웹브라우저가 처리할 수 있는 메시지 바디의 압축 방식을 지정하는 헤더이다.  
웹브라우저는 자신이 받을 수 있는 콘텐츠 코딩 형식을 Accept-Encoding 헤더에 설정해 요청한다. 이에 웹 서버는 Accept-Encoding 헤더 안에 선택한 콘텐츠 코딩 형식으로 HTTP 메시지를 압축하고, 그 방식을 Content-Encoding 헤더에 설정한 뒤 웹브라우저에 응답한다.  

 - `요청 헤더`
    - 요청 헤더는 요청 메시지를 제어하기 위한 헤더를 말한다.
    - RFC2616에서는 19종류의 요청 헤더를 정의하고 있다.
        - Accept: 텍스트 파일이나 동영상 파일 등 웹브라우저가 받을 수 있는 미디어 타입
        - Accept-Charset: Unicode나 ISO 등 웹브라우저가 처리할 수 있는 문자셋
        - Accept-Encoding: gzip이나 compress 등 웹브라우저가 처리할 수 있는 메시지 바디 압축(콘텐츠 코딩) 타입
        - Accept-Language: 한국어나 영어 등 웹 브라우저가 처리할 수 있는 언어셋
        - Expect: 송신하는 요청 메시지가 클 때, 서버가 받을 수 있는지 확인한다.
        - From: 사용자 메일 주소, 연락처를 전달하기 위해 사용한다.
        - Host: 웹브라우저가 요청하는 웹서버의 도메인 이름(FQDN)
            - Host 헤더는 필수 항목으로 웹브라우저가 리퀘스트하는 웹서버의 도메인 이름(FQDN)과 포트번호가 설정된다.
        - If-Match: 조건부 요청. 서버는 요청에 포함된 ETag(Entity Tag) 헤더값이 서버상의 특정 리소스에 연결된 ETag값과 일치하면 응답을 반환한다.
        - If-Modified-Since: 조건부 요청. 서버는 이 날짜 이후에 업데이트된 리소스에 대한 요청인 경우 응답을 반환한다.
        - If-None-Match: 조건부 요청. 서버는 요청에 포함된 ETag 헤더값이 서버상의 특정한 리소스에 연결된 ETag 값과 일치하지 않으면 응답을 반환한다.
        - If-Range: 조건부 요청. 값으로 ETag 또는 업데이트 일시를 넣고, Range 헤더와 함께 사용한다. 서버는 ETag 또는 업데이트 일시가 일치하면 Range 헤더를 처리한다.
        - If-Unmodified-Since: 조건부 요청. 서버는 이 날짜 이후에 업데이트되지 않은 리소스에 대한 요청인 경우 응답을 반환한다.
        - Max-Forwards: TRACE 또는 OPTIONS 메서드에서 전송해도 좋은 서버의 최대수
        - Proxy-Authorization: 프록시 서버에 대한 인증 정보
        - Range: 리소스의 일부를 얻는 범위 요청일 때 사용한다. (ex: 1000 Byte ~ 2000 Byte)
        - Referer: 직전에 링크되었던 URL
        - TE: 웹브라우저가 받을 수 있는 메시지 바디의 분할(전송 코딩) 타입
        - User-Agent: 웹브라우저 정보(웹브라우저나 OS 등 사용자의 환경 정보)
 - `응답 헤더`
    - 응답 헤더는 응답 메시지를 제어하기 위한 헤더를 말한다.
    - RFC2616에서는 9종류의 응답 헤더를 정의하고 있다.
        - Accept-Ranges: 텍스트 파일이나 이미지 파일 등 웹브라우저가 받을 수 있는 미디어 타입
        - Age: 오리진 서버의 리소스가 프록시 서버에 캐시된 후의 경과 시간(단위=초)
        - ETag: 엔티티 태그. 파일 등의 리소스를 유일하게 식별하는 문자열. 리소스가 업데이트되면 ETag도 업데이트된다.
            - 서버의 리소스를 유일하게 식별하기 위한 헤더로 리소스가 수정될 때 변경된다. 이 값을 활용해 IF-Match 헤더, IF-None-Match 헤더 등의 요청 헤더와 조합해 사용한다.
            - ETag가 일치하지 않을 때는 리소스가 수정되어 콘텐츠를 반환하고, ETag가 일치햇을 때는 리소스 수정이 없어 '304 Not Modified'를 반환한다. (수정이 없을 때 콘텐츠를 다운로드하지 않고, 캐시에서 사용한다.)
        - Location: 리다이렉트할 때의 리다이렉트 위치
        - Proxy-Authenticate: 프록시 서버로부터 클라이언트에 대한 인증 요청 및 인증 방식
        - Retry-After: 요청을 재실행할 때까지의 시간
        - Server: 웹서버로 사용하는 서버 소프트웨어의 이름, 버전, 옵션
            - Server 헤더에는 웹서버의 정보가 설정된다. OS, 버전, 소프트웨어 등이 설정되는데 악의를 가진 사용자가 해당 정보를 보고 해당 소프트웨어의 취약성을 기반으로 공격할 수 있으므로 비활성화한다.
            - Apache에서는 'mod_headers'라는 모듈을 사용해 비활성화할 수 있다.
        - Vary: 오리진 서버로부터 프록시 서버에 대한 캐시 관리 정보. Vary 헤더로 지정한 HTTP 헤더의 요청에만 캐시를 사용한다.
        - WWW-Authenticate: 웹서버로부터 클라이언트에 대한 인증 요구 및 인증 방식
 - `일반 헤더`
    - 일반 헤더는 요청과 응답 모두에서 범용으로 사용되는 헤더이다.
    - 웹브라우저와 웹서버에 의해 필요에 따라 선택되어 HTTP 메시지 전체를 제어한다.
    - RFC2616에서는 9종류의 일반 헤더를 정의하고 있다.
        - Cache-Control: 웹브라우저에 일시적으로 보존하는 캐시 제어. 캐시를 하지 않거나, 캐시를 하는 시간을 설정할 수 있다.
            - Cache-Control 헤더는 웹브라우저나 서버의 캐시를 제어하기 위해 사용된다.
            - 캐시는 프라이빗 캐시와 공유 캐시 2가지 종류가 있다. 프라이빗 캐시는 클라이언트의 웹브라우저에 저장되고, 공유 캐시는 프록시 서버나 CND의 엣지 서버에 저장되는 캐시이다.
            - Cache-Control 헤더는 디렉티브 명령어를 필드값으로 저장해 캐시 여부, 공유 기한, 캐시 위치 등을 제어한다.
            - __요청 디렉티브__
                - no-cache: 유효성을 확인하지 않으면 캐시를 사용하지 않는다.
                - no-store: 프라이빗 캐시, 공유 캐시에 관계없이 캐시를 사용하지 않는다.
                - max-age=[sec]: 캐시의 유효 기간을 지정한다.
            - __응답 디렉티브__
                - public: 공유 캐시로 캐시한다.
                - private: 공유 캐시로 캐시하지 않는다.
                - no-cache: 유효성을 확인하지 않으면 캐시를 사용하지 않는다.
                - no-store: 프라이빗 캐시, 공유 캐시에 관계없이 캐시를 사용하지 않는다.
                - must-revalidate: 캐시의 유효 기간이 넘은 경우, 유효성을 확인하지 않으면 캐시하지 않는다.
                - max-age=[sec]: 캐시의 유효 기간을 지정한다.
                - s-mac-age=[sec]: 공유 캐시에 대해 max-age보다도 우선하는 유효 기간을 지정한다.
                - immutable: 유효성을 확인하지 않고 캐시를 사용한다.
        - Connection: 킵얼라이브의 연결 관리 정보. 킵얼라이브에 대응하는 것을 알리고, TCP 커넥션을 클로즈할 때 사용한다.
        - Date: HTTP 메시지를 생성한 일시
        - Pragma: 캐시에 관해 HTTP/1.0과의 하위 호환성을 목적으로 사용한다.
        - Trailer: 메시지 바디 뒤에 기술하는 HTTP 헤더를 알린다. 청크(Chunk) 전송 인코딩을 사용할 때 사용할 수 있다.
        - Transfer-Encoding: 메시지 바디의 전송 코딩 타입
        - Upgrade: 다른 프로토콜 또는 다른 버전으로 전환한다.
        - Via: 경유한 프록시 서버를 추가로 기술한다. 루프 회피를 목적으로 사용한다.
        - Warning: HTTP 메시지에 반영되지 않은 상태나 메시지의 변화에 관한 추가 정보
 - `엔티티 헤더`
    - 엔티티 헤더는 요청과 응답에 포함되는 메시지 바디에 관련한 제어 정보를 포함하는 헤더이다.
    - RFC2616에서는 10종류의 엔티티 헤더를 정의하고 있다.
        - Allow: 서버가 클라이언트에게 대응하는 메서드를 알린다.
        - Content-Encoding: 서버가 실행한 메시지 바디의 압축(콘텐츠 코딩)의 타입
        - Content-Language: 한국어, 영어 등 메시지 바디에 사용된 언어셋
        - Content-Length: 메시지 바디 크기, 바이트 단위로 기술
        - Content-Location: 메시지 바디의 URI
        - Content-MD5: 메시지 바디에 대한 MD5 해시값, 변조 감지에 사용
        - Content-Range: 범위 요청에 대한 응답에 사용
        - Content-Type: 텍스트 파일이나 이미지 파일 등 메시지 바디의 미디어 타입
        - Expires: 리소스의 유효 기간 일시
        - Last-Modified: 리소스가 가장 마지막으로 수정된 일시
 - `기타 헤더`
    - Set-Cookie: 서버가 세션 관리에 사용하는 세션 ID나 사용자 개별 설정 등을 웹브라우저로 전송한다.
    - Cookie: 웹브라우저가 Set-Cookie를 통해 주어진 Cookie 정보를 서버에 전송한다.
    - X-Forwarded-For: 부하 분산 장치로 NAPT되는 환경에서 변환 전의 IP 주소를 저장한다.
        - AWS의 부하 분산 장치인 ELB나 ALB를 사용하면 송신지 IP 주소가 ELB/ALB의 IP 주소로 변환된다. 때문에, 단순 송신지 IP 주소를 보고 실제로 어느 IP 주소로부터 액세스되었는지 알 수 없다. X-Forwarded-For의 값을 보고 어느 IP 주소로부터 액세스 되었는지 특정한다.
    - X-Forwarded-Proto: 클라이언트가 사용하고 있는 프로토콜을 저장. 부하 분산 장치에서 SSL 오프로드하는 환경 등에서 원 프로토콜을 특정할 떄 사용한다.
        - 부하 분산 장치에는 처리 부하가 되기 쉬운 SSL 처리를 서버에서 대신하는 SSL 오프로드 기능이 있다. SSL 오프로드는 부하 분산 장치가 HTTPS를 복호화해서 HTTP로 변환하기 때문에 클라이언트 요청에사용한 원 프로토콜을 알 수 없게 된다. X-Forwarded-Proto의 값을 보고 원 프로토콜을 특정한다.

<br/>

### HTTP/2의 메시지 포맷

HTTP/2는 HTTP/1.1의 기본 요소나 그 역할을 유지하면서, 교환하는 형식을 바꿈으로써 전송 효율을 향상한 것이다.  

HTTP/1.1의 텍스트 형식은 사람이 이해하기 쉽지만, 컴퓨터가 해석하기 위해서는 바이너리 형식으로의 변환 처리가 필요하다.  
HTTP/2는 메시지 헤더를 HEADERS 프레임에, 메시지 바디를 DATA 프레임에 각각 분할해서 저장하고, 바이너리 형식의 프레임 단위로 스트림에 보낸다. 그리고 그떄 프레임에 스트림을 식별하는 스트림 ID를 부여해서 어떤 스트림에 프레임을 보냈는지 지정한다.  

 - `RFC7540에 정의된 프레임 종류`
    - DATA: 메시지 바디를 저장한다.
    - HEADERS: 메시지 헤더를 저장한다.
    - PRORITY: 스트림 우선 순위를 변경한다.
    - RST_STREAM: 스트림 취소가 요청되거나 스트림 오류가 발생했을 때 스트림을 즉시 종료한다.
    - SETTINGS: 동시 스트림 수나 서버 푸시 비활성화 등 커넥션에 관한 연결 설정을 변경한다.
    - PUSH_PROMISE: 서버로부터 데이터를 푸시하는 스트림을 예약한다.
    - PING: 커넥션을 유지하거나 왕복 지연 시간(RTT)를 측정한다.
    - GOAWAY: 통신하는 데이터가 없거나 중요한 에러가 발생했을 때 커넥션을 끊는다.
    - WINDOW_UPDATE: 흐름 제어를 위해 윈도우 크기를 변경한다.
    - CONTINUATION: 하나의 프레임에 담을 수 없는 HEADERS 프레임이나 PUSH_PROMISE의 이어진 부분을 송신한다.

<br/>

 - `요청 라인과 상태 라인`
    - __요청 라인__
        - HTTP/1.1의 요청 라인은 HTTP 메서드, 요청 URI, HTTP 버전을 텍스트로 송신한다.
        - HTTP/2는 메서드를 :method 헤더에, 요청 URI를 :path 헤더에, HTTP 버전을 :version 헤더에 각각 저장한 뒤 HEADERS 프레임으로 송신한다.
    - __상태 라인__
        - HTTP/1.1의 상태 라인은 HTTP 버전, HTTP 상태 코드, 원인 문장을 텍스트로 송신한다.
        - HTTP/2는 HTTP 버전을 :version 헤더에, 상태 코드를 :status 헤더에 각각 저장한 뒤 HEADERS 프레임으로 송신한다.
        
<div align="center">
    <img src="./images/HTTP2_Request_Message_Format.PNG"><br/>
    요청 라인<br/>
    <img src="./images/HTTP2_Response_Message_Format.PNG"><br/>
    상태 라인
</div>
<br/>

 - `프로토콜 업그레이드`
    - __SSL 핸드셰이크 패턴__
        - SSL 핸드셰이크란 SSL/TLS로 암호화 통신하기 전에 수행하는 사전 준비이다.
        - 간단히 보안을 확보하기 위해 암호화 방식이나 인증 방식을 결정하거나 상호 인증을 하거나 암호화에 사용할 공통키를 교환한다.
        - HTTP/2로 연결할 때는 SSL 핸드셰이크의 ALPN 확장 기능을 사용한다.
    - __HTTP 헤더 패턴__
        - 웹브라우저는 최초에 HTTP/1.1로 GET 요청을 하는데, 이때 Upgrade 헤더를 붙여 'HTTP/2에도 대응한다'라고 전달한다.
        - 서버가 HTTP/2에 대응하면 '101 Switching Protocol' 상태 코드를 반환하고 HTTP/2로 이행한다. 만약, 서버가 대응하지 않으면 HTTP/1.1로 연결한다.

<br/>

## SSL/TLS

SSL/TLS는 데이터를 암호화하거나 통신 상대를 인증하는 등으로 중요한 데이터를 보호한다.  

<br/>

### SSL에서 이용하는 기술

SSL은 암호화, 해시화, 디지털 인증서 3가지 기술을 조합해 사용하여 인터넷상에 존재하는 다양한 보안 위협에 대항한다.  

 - `SSL로 방지할 수 있는 위협`
    - __암호화를 통한 도청 방지__
        - 암호화는 정해진 규칙에 기반해 데이터를 변환하는 기술이다.
        - 암호화를 통해 제 3자가 데이터를 엿보는 도청을 방지한다. SSL은 암호화를 통해 도청되더라도 내용을 알 수 없도록 한다.
    - __해시화를 통한 변조 방지__
        - 해시화는 애플리케이션 데이터로부터 정해진 계산에 기반해 고정된 길이의 데이터를 추출하는 기술이다.
        - 서버는 데이터로부터 계산해서 얻은 해시값과 함께 전송된 해시값을 비교한다. 같은 데이터에 대해 같은 계산을 통해 해시값이 같으면 변조되지 않았음을 알 수 있다.
    - __디지털 인증서를 통한 신분 위조 방지__
        - 디지털 인증서는 해당 단말이 진짜임을 증명하는 파일로 신분 위조를 방지할 수 있다.
        - SSL에서는 데이터를 송신하기 전에 클라이언트 정보를 요청하고, 전송받은 디지털 인증서를 기반으로 올바른 상대인가를 확인한다.
        - 디지털 인증서의 진위 여부는 인증 기관(CA)이라 부르는 신뢰할 수 있는 제 3자 기관의 디지털 서명으로 판단한다.
 - `SSL에서 이용하는 암호화 방식`
    - SSL의 암호화 처리에는 데이터 암호화를 위한 암호화키, 암호화를 풀기 위한 복호화키가 필요하다.
    - __공통키(대칭키) 암호화 방식__
        - 공통키 암호화 방식은 암호화/복호화 시에 동일한 키를 사용하는 암호화 방식이다.
        - 클라이언트와 서버는 미리 같은 키를 공유하고, 암호화키로 암호화한 뒤 암호화키와 완전히 같은 키로 복호화한다.
        - 공통키 암호화 방식은 암호화와 복호화 처리 속도가 빠르다. 하지만, 키 전송 문제가 발생할 수 있다.
    - __공개키 암호화 방식__
        - 공개키 암호화 방식은 암호화/복호화 시에 서로 다른 키를 사용하는 암호화 방식이다. RSA, DH/DHE, ECDH/ECHDE 방식을 사용한다.
        - 공개키 암호화 방식은 키를 전송할 필요가 없다. 때문에, 키 전송에 신경쓰지 않아도 된다. 하지만, 공개키 암호화 방식은 처리가 복잡하기 대문에 그만큼 암호화 처리와 부호화 처리에 시간이 소요되며 처리 부하가 걸린다.
        - 공개키 암호화 방식 흐름
            - 1번째: 웹서버는 공개키와 비밀키 쌍을 만든다.
            - 2번째: 웹서버는 공개키를 모두에게 공개/배포하고 비밀키만 보관한다.
            - 3번째: 웹브라우저는 공개키를 암호화키로 사용해서 데이터를 암호화한 뒤 전송한다.
            - 4번째: 웹서버는 비밀키를 복호화키로 사용해서 데이터를 복호화한다.
    - __하이브리드 암호화 방식__
        - 공개키 암호화 방식은 처리 속도가 빠르지만 키 전송 문제가 발생할 수 있고, 공개키 암호화 방식은 키 전송 문제가 없어 안전하지만 처리 속도가 느리다는 단점이 있다. SSL은 두 암호화 방식을 조합하여 처리 효율을 높인다.
        - 하이브리드 암호화 방식 흐름
            - 첫 요청에서 공개키 암호화 방식을 이용하고, 공통키(대칭키)를 만들어 반환한다. 이후 2번째 요청부터는 만들어진 공통키(대칭키)로 암복호화를 수행한다. (세션키)
            - 1번째: 웹서버는 공개키와 비밀키 쌍을 만든다.
            - 2번째: 웹서버는 공개키를 모두에게 공개/배포하고 비밀키만 보관한다.
            - 3번째: 웹브라우저는 공통키의 재료를 공개키로 암호화해서 보낸다.
            - 4번째: 웹서버는 공통키의 재료를 비밀키로 복호화한다.
            - 5번째: 웹서버와 웹브라우저는 공통키의 재료로부터 공개키를 생성한다.
            - 6번째: 웹브라우저는 애플리케이션 데이터를 공통키로 암호화한다.
            - 7번째: 웹서버는 애플리케이션 데이터를 공통키로 복호화한다.
    - __SSL에서 이용하는 해시 함수__
        - 해시 함수는 데이터가 1비트라도 다르면 해시값이 완전히 다른값이 된다. 이 성질을 이용해 데이터 변조를 감지한다.
        - 단방향 해시 함수는 데이터를 통해 해시값을 만든다. 만들어진 해시값은 복원할 수 없다. 때문에, 누군가 해시값을 훔치더라도 보안상 문제가 되지 않는다.
        - SHA-256 방식의 단방향 해시 함수로 산출되는 해시값은 원 데이터의 크기에 관계없이 256 비트로 만들어진다. 일정 길이만 비교하면 되므로 처리 속도를 높일 수 있다.
    - __디지털 인증서 검증__
        - 디지털 인증서는 서명 전 인증서, 디지털 서명 알고리즘, 디지털 서명으로 구성된다.
            - 서명 전 인증서는 서버나 서버 소유자의 정보이다. 서버의 URL을 나타내는 공통 이름이나 인증서 유효 기간, 공개키 등이 여기에 포함된다. (버전, 시리얼 번호, 발행자, 유효 기간, 공개키 등)
            - 디지털 서명 알고리즘에는 디지털 서명에서 사용하는 해시 함수 이름이 포함된다.
            - 디지털 서명은 서명 전 인증서와 디지털 서명 알고리즘으로 지정된 해시 함수로 해시화한 뒤, 인증 기관의 비밀키로 암호화한 것이다.
        - 디지털 인증서를 받은 수신자는 디지털 서명을 인증 기관의 공개키(CA 인증서)로 복호화해서 서명 전 인증서의 해시값과 비교 및 검증한다.
 - `SSL에서 이용하는 기술 정리`
    - 사전 준비
        - 공개키 암호화 방식: 공통키 재료를 전송한다.
        - 디지털 서명: 제 3자로부터 인증을 받는다.
    - 암호화 데이터 통신
        - 공통키 암호화 방식: 애플리케이션 데이터를 암호화한다.
        - 메시지 인증 코드: 애플리케이션 데이터에 공통키를 붙여 해시화한다.

<br/>

### SSL 버전

SSL은 SSL 2.0, SSL 3.0, TLS 1.0, TLS 1.1, TLS1.3으로 5번의 버전 업그레이드를 거쳤다.  
어느 버전을 사용하는지는 암호화 통신에 앞서 공개키 방식으로 수행되는 SSL 핸드셰이크에 따라 결정된다.

 - `SSL 1.0/ SSL2.0 (1994년)`
    - SSL의 기초가 된 버전
    - Netscape Communications가 작성
    - 다운그레이드 공격, 버전 롤백 공격 등 치명적인 취약성이 발견되어 최근에는 사용하지 않음
    - RFC6176에서 SSL 2.0 사용 금지 명시
 - `SSL 3.0 (1995년)`
    - SSL 2.0의 취약성 문제를 해결한 버전
    - 기존에 RFC에 표준화되지 않았지만, 2011년에 역사적 가치가 인정받아 RFC6101로 공개됨
    - Netscape Communications가 작성
    - SSL의 대표 주자로 오랜 기간 사용되었지만, POODLE 공격 취약성이 발견되어 최근에는 사용하지 않음
    - RFC7568에서 폐지됨
 - `TLS 1.0 (1999년)`
    - RFC2246으로 규격화
    - 기본적인 사용은 SSL 3.0과 크게 다르지 않음
    - 암호화 방식이나 해시화 방식 일부 변경
    - AES나 Camellia 등 강력한 암호화 방식에 대응함으로 안전성 향상되어 20년 이상 사용되었지만, 암호화 방식이나 인증 방식 노후화로 2020년에 주요 4대 브라우저에서 지원 중단 발표
 - `TLS 1.1 (2006년)`
    - RFC4346으로 규격화
    - TLS 1.0에서 이어진 보안 강화
    - BEAST 공격 대책에 따른 CBC 블록 암호 사양 변경
    - 수출용 암호 폐지
    - TLS 1.1 역시 2020년 주요 4대 브라우저에서 지원 중단 발표
 - `TLS 1.2 (2008년)`
    - RFC5246으로 규격화
    - TLS 1.1에서 이어진 보안 강화
    - SHA-256, AES-GCM 대응
    - MD5, SHA-1 폐지
 - `TLS 1.3 (2018년)`
    - RFC8446으로 규격화
    - TLS 1.2보다 강도 높은 해시 함수/암호화 방식
    - SSL 핸드셰이크 단순화

<br/>

### SSL 레코드 포맷

SSL 레코드는 SSL 제어 정보를 다루는 SSL 헤더와 SSL 페이로드로 구성된다.  
또한, SSL 헤더는 콘텐츠 타입, 프로토콜 버전, SSL 페이로드 길이 3 가지 필드로 구성된다.  

 - `콘텐츠 타입`
    - SSL 레코드 종류를 나타내는 1바이트 필드
    - __핸드셰이크 레코드(22)__ : 암호화 통신에 앞서 수행되는 SSL 핸드셰이크에서 사용하는 레코드
        - Hello Request(0): Client Hello를 요청하는 레코드, 이를 받은 클라이언트는 Client Hello를 송신한다.
        - Client Hello(1): 클라이언트가 대응하는 암호화 방식이나 해시화 방식, 확장 기능 등을 서버에 알리는 레코드
        - Server Hello(2): 서버가 대응을 확정한 암호화 방식이나 해시화 방식, 확장 기능 등을 클라이언트에게 알리는 레코드
        - Certificate(11): 디지털 인증서를 송신하는 코드
        - Server Key Exchange(12): 서버가 인증서를 갖고 있지 않을 때, 일시적으로 사용하는 키를 전송하는 레코드
        - Cerficate Request(13): 클라이언트 인증에서 클라이언트가 인증서를 요청하는 레코드
        - Server Hello Done(14): 서버로부터 클라이언트에 대해 모든 정보를 보냈음을 나타내는 레코드
        - Certificate Verify(15): 클라이언트 인증에서 지금까지 교환한 SSL 핸드셰이크 정보를 해시화해서 송신하는 레코드
        - Client Key Exchange(16): 실제 암호화 통신에 사용하는 공통키의 재료를 송신하는 레코드
        - Finished(20): SSL 핸드셰이크가 완료되었음을 나타내는 레코드
    - __암호 사양 변경 레코드(20)__ : 암호화나 해시화에 관한 사양을 확정하거나, 변경하기 위해 사용하는 레코드
        - SSL 핸드셰이크에 따라 결정된 다양한 사양을 확장하거나 변경하기 위해 사용
        - 해당 레코드 이후 통신은 모두 암호화된다.
    - __얼럿 레코드(21)__ : 상대에 대해 에러를 알리기 위해 사용하는 레코드
        - close_notify(0): SSL 세션을 닫을 때 사용하는 레코드
        - unexpectied_message(10): 예상할 수 없는 부적절한 레코드를 수신했음을 나타내는 레코드
        - bad_record_mac(20): 올바르지 않은 MAC 값을 수신했음을 나타내는 레코드
        - decription_failed(21): 복호화에 실패했음을 나타내는 레코드
        - record_overflow(22): SSL 레코드의 크기 상한을 넘는 레코드를 수신했음을 나타내는 레코드
        - decompression_failure(30): 압축 풀기 처리에 실패했음을 나타내는 레코드
        - handshake_failure(40): 일치하는 암호화 방식 등이 없어, SSL 핸드셰이크에 실패했음을 나타내는 플래그
        - no_certificate(41): 클라이언트 인증에서 클라이언트 인증서가 없음을 나타내는 레코드
    - __애플리케이션 데이터 레코드(23)__ : 애플리케이션 데이터를 나타내는 레코드
 - `프로토콜 버전`
    - SSL 레코드의 버전을 나타내는 2바이트 필드
    - 상위 1바이트는 메이저 버전, 하위 1바이트는 마이너 버전을 나타낸다.
        - SSLv2.0: 20
        - SSLv3.0: 30
        - TLSv1.0: 31
        - TLSv1.1: 32
        - TLSv1.2: 33
        - TLSv1.3: 33 (TLS 1.3은 하위 호환성을 고려해 TLS 1.2와 같은 프로토콜 버전 사용)
 - `SSL 페이로드 길이`
    - SSL 페이로드의 길이를 바이트 단위로 정의한 2바이트 필드
    - 이론상 최대 65536 바이트 레코드를 다룰 수 있지만, RFC5246에서는 16384 바이트 이하가 되도록 정의한다.
    - 16384 바이트가 넘을 때는 바이트를 분할하여 암호화한다.

<br/>

### SSL 접속에서 종료까지 흐름

 - `서버 인증서 준비`
    - HTTPS 서버를 이용하기 위해서는 서버 인증서를 준비하고, 인증 기관으로 신청 등을 사전에 준비해야 한다.
    - 준비 흐름
        - 1번째: HTTPS 서버에서 비밀키를 만든다.
            - 비밀키는 '-----BEGIN RSA PRIVATE KEY-----'로 시작해서 '-----END RSA PRIVATE KEY-----'로 끝나는 파일이다.
        - 2번째: 1번에서 만든 비밀키를 기반으로 CSR을 만들어 인증 기관에 보낸다.
            - CSR는 서버 인증서를 얻기 위해 인증 기관에 제출하는 신청서이다.
            - CSR을 만들기 위해서는 고유 이름이 필요하며, 고유 이름에는 URL 정보, 조직명, 부서이름, 주소지, 국가코드 등이 포함된다.
            - CSR은 '-----BEGIN CERTIFICATE REQUEST-----'로 시작해서 '-----END CERTIFICATE REQUEST-----'로 끝나는 파일이다.
        - 3번째: 인증 기관은 여러 프로세스를 디지털 서명을 만들고, 서버 인증서를 요청자에게 보낸다.
            - 인증 기관은 신청자 신원을 조회한다. 조사를 통과하면 CSR을 해시화, 인증 기관의 비밀키로 암호화해서 디지털 서명으로 만든다. 이후 서버 인증서를 발생하고 요청자에게 송신한다.
            - 서버 인증서는 '-----BEGIN CERTIFICATE-----'로 시작해서 '-----END CERTIFICATE-----'로 끝나는 파일이다.
        - 4번째: 인증 기관에서 받은 서버 인증서를 서버에 설치한다.
            - 최근 인증 기관은 중간 인증서(중간 CA 인증서, 체인 인증서)도 함꼐 설치하도록 되어 있다.
 - `SSL 핸드셰이크를 통한 사전 준비`
    - 서버 인증서를 설치했다면 웹브라우저는 SSL 접속을 받을 수 있다.
    - SSL은 바로 메시지를 암호화해서 보낼 수 있는 것이 아니고, 메시지 암호화를 하기 전에 SSL 핸드셰이크 단계를 갖는다.
    - __SSL 핸드셰이크 과정__
        - 1번째: 대응하는 암호화 방식과 해시 함수 제시
            - Client Hello
                - 클라이언트는 웹브라우저가 사용할 수 있는 암호화 방식이나 단방향 해시 함수를 서버로 제시한다.
                - 그 외에도 SSL이나 HTTP의 버전, 공통키 작성에 필요한 Client Random 등 확장 기능의 파라미터도 전송한다.
                - SSL 버전, 현재 시각, Client Random, 세션 ID, 사용할 수 있는 암호화/해시화 방식, 사용할 수 있는 압축 방식
        - 2번째: 통신 상대 증명
            - Server Hello
                - 서버는 Client Hello에서 받은 암호 스위트 리스트와 자신이 가진 암호 스위트 리스트를 참조해 일치한 암호 스위트 안에서 가장 우선도가 높은 암호 스위트를 선택한다.
                - 응답으로 암호 스위트와 HTTP 버전, 공통키 작성에 사용하는 Server Randome 등을 반환한다.
            - Certificate
                - 자기 자신의 서버 인증서를 보내고, 자신이 제3자 기관으로부터 인증받은 본인이라는 것을 증명한다.
                - 서명 전 인증서(서버 소유자 정보)를 디지털 서명 알고리즘에 명시된 해시 함수로 해시화하고, 인증 기관의 비밀키로 암호화한 서버 인증서를 클라이언트에 전송한다.
                - 클라이언트는 서버 인증서를 인증 기관의 공개키(CA 인증서)로 복호화해서 서명 전 인증서의 해시값과 비교 및 검증한다.
            - Server Hello Done
                - 서버의 모든 정보를 보냈다고 알린다.
                - 웹 브라우저는 받은 서버 인증서를 검증(루트 인증서로 복호화 -> 해시값 비교)하고, 올바른 서버인지 확인한다.
        - 3번째: 공통키 교환
            - 이 단계에서 애플리케이션 데이터의 암호화와 해시화에 사용할 공통키의 자료를 교환한다.
            - 웹브라우저는 통신 상대가 실제 서버인 것을 확인하면 프리 마스터 시크릿(pre-master secret)이라는 공통키의 재료를 만들어 서버에 보낸다.
            - HTTPS 서버는 프리 마스터 시크릿과 Client Hello로 얻은 Client Random 값과 Server Hello에서 얻은 Server Randome을 섞어 마스터 시크릿(master secret)을 만든다.
            - 해당 마스터 시크릿을 이용해 애플리케이션 데이터의 암호화에 사용하는 공통키 세션키와 해시화에 사용하는 MAC키를 만든다.
            - 요약: 웹브라우저는 Client Key Exchange로 프리 마스터 시크릿을 공개키로 암호화해서 보낸다. 이를 받은 서버는 비밀키로 복호화해서 프리 마스터 시크릿을 추출하고 Client Random과 Server Random을 섞어 마스터 시크릿을 만든다. 이후 마스터 시크릿에서 세션키와 MAC 키를 만든다.
        - 4번째: 최종 확인 작업
            - 클라이언트와 서버 서로 Change Cipher Spec과 Finished를 교환하고, 결정한 사항들을 확인하고, SSL 핸드셰이크를 종료한다.
            - 이 과정이 종료되면 SSL 세션이 만들어지고, 애플리케이션 데이터 암호화 통신을 시작한다.
    - __암호화 통신__
        - SSL 핸드셰이크가 끝나면 애플리케이션 데이터 암호화 통신을 시작한다.
        - 애플리케이션 데이터를 MAC키로 해시화하고, 세션키로 암호화해서 애플리케이션 데이터 레코드로 전송한다.
    - __SSL 세션 재이용__
        - 최초 요청에서 SSL 핸드셰이크로 만들어진 세션 정보를 캐시해서 2번째 이후에 재사용하는 SSL 세션 재이용 기능을 제공한다.
    - __SSL 세션 종료__
        - 세션을 닫을 때는 웹브라우저 혹은 서버에 관계없이 종료하고 싶은 측에서 close_notify를 송출한다.
        - TCP의 4 Way HandShake 과정을 거치고 TCP 커넥션을 종료한다.

<div align="center">
    <img src="./images/SSL_Handshake.PNG">
</div>
<br/>

### 클라이언트 인증서를 이용한 클라이언트 인증

SSL에서는 서버를 인증하는 서버 인증, 클라이언트를 인증하는 클라이언트 인증 2가지 인증 구조를 제공한다.  
클라이언트 인증은 미리 웹브라우저에서 설치한 클라이언트 인증서를 이용해 클라이언트를 인증한다.  

 - `클라이언트 인증서 요청`
    - 기존에 Client Hello, Server Hello, Certificate 흐름은 동일하게 진행된다.
    - HTTPS 서버는 Certificate로 서버 인증서를 송신한 뒤, Certificate Request로 클라이언트 인증서를 요청한다.
    - 이후 Server Hello Done으로 자신의 정보를 모두 보냈음을 알린다.
 - `클라이언트 인증서 전송`
    - 웹브라우저는 Certificate(클라이언트)에 미리 설치된 클라이언트 인증서를 송신한다.
    - 만약, Certificate Request에 적합한 클라이언트 인증서를 갖고 있지 않다면 'no_certificate'를 반환하고, 서버는 TCP 커넥션을 닫는다.
    - 적합한 클라이언트 인증서를 가졌을 때는 웹브라우저상에서 어떤 클라이언트 인증서를 보낼지 선택한 뒤 전송한다.
 - `이제까지의 해시값을 송부`
    - 클라이언트 인증서를 송신한 웹브라우저는 계속해서 Client Key Exchange로 프리 마스터 시크릿을 송싱한다.
    - 계속해서 Certificate Verify로 이제까지의 교환을 해시화, 비밀키로 암호화해서 디지털 서명으로 송신한다.
    - Certificate Verify를 받은 서버는 Certificate 안에 포함된 공개키를 복호화하고, 스스로 계산한 해시값과 비교해 변조되지 않았음을 확인한다.
    - 이후 Change Cipher Spec과 Finished를 서로 송신하고, 실제 애플리케이션 데이터의 암호화 통신을 진행한다.

<br/>

## DNS

DNS는 IP 주소와 도메인 이름을 상호 교환하는 프로토콜이다.  
DNS는 IP 주소를 사람이 이해하기 쉬운 형태로 통신할 수 있게 한다.  

실제 웹브라우저에서 웹사이트에 액세스할 때 먼저 웹브라우저가 DNS 서버에게 해당 도메인에 할당되어 있는 IP 주소를 문의하고, 응답받은 IP 주소에 HTTPS로 액세스한다.  

<br/>

### 도메인 이름

도메인 이름은 FQDN이라 불리며 호스트 부분과 도메인 부분으로 구성되어 있다.  
호스트 부분은 FQDN의 가장 왼쪽에 있는 라벨로 컴퓨터 그 자체를 나타낸다.  
도메인 부분은 오른쪽부터 순서대로 루트/탑 레벨 도메인, 세컨드 레벨 도메인, 서드 레벨 도메인 으로 구성되며, 국가나 조직 혹은 기업 등을 나타낸다.  

탑 레벨 도메인에는 지역별로 할당된 ccTLD와 특정한 영역/분야에 할당된 gLTD 2가지 종류가 있다.  

 - ccTLD(국가별 코드 탑 레벨 도메인)
    - kr: 한국
    - us: 미국
    - uk: 영국
    - fr: 프랑스
    - de: 독일
    - au: 오스트레일리아
 - gTLD(분야별 코드 탑 레벨 도메인)
    - com: 커머셜 사이트용 도메인
    - net: 네트워크 관련 서비스용 도메인
    - org: 비영리 조직용 도메인
    - app: 애플리케이션 관련 서비스용 도메인
    - cloud: 클라우드 관련 서비스용 도메인
    - blog: 블로그 관련 서비스용 도메인
 - www.example.co.kr
    - 호스트 이름: www (ns1, ns2, www, mail 등)
    - 서드 레벨 도메인(3LD): example (google, yahoo, example 등)
    - 세컨드 레벨 도메인(2LD): co (or, ne, co, ad 등)
    - 탑 레벨 도메인(TLD): kr (분야:gov, com, net, 국가:uk, kr, us 등)

<br/>

### 이름 결정과 존 전송

 - `이름 결정`
    - IP 주소와 도메인 이름을 서로 교환 처리를 이름 결정이라 부른다.
    - __DNS 클라이언트(스텝 리졸버)__
        - DNS 클라이언트는 DNS 서버에 이름 결정을 요청하는 클라이언트 단말/소프트웨어를 말한다.
        - DNS 클라이언트는 캐시 서버에 대해 이름 결정 요청을 송신한다. 그리고 캐시 서버로부터 받은 응답의 결과를 일정 시간 캐시해두고, 같은 질문이 있을 때 재이용함으로써 DNS 트래픽을 억제한다.
        - ex) Windows OS의 nslookup, Linux OS의 dig 명령어 등
    - __캐시 서버(참조 서버)__
        - 캐시 서버는 DNS 클라이언트로부터 재귀 쿼리를 받아 인터넷상에 있는 권위 서버로 이름 결정 요청을 송신하는 DNS 서버를 말한다.
        - DNS 클라이언트가 인터넷상에 공개되어있는 서버에 액세스할 때 사용되며, 캐시 서버도 DNS 클라이언트와 마찬가지로 권위 서버로부터 받은 응답 결과를 일정 기간 캐시해두고, 재이용함으로써 DNS 트래픽을 억제한다.
    - __권위 서버(존 서버)__
        - 권위 서버는 자신이 관리하는 도메인에 관해 캐시 서버로부터의 반복 쿼리를 받아들이는 DNS 서버를 말한다.
        - 자신이 관리하는 도메인 범위(존)에 관련된 각종 정보를 존 파일 이라는 데이터베이스에 리소스 레코드 형태로 저장한다.
        - 루트 서버는 탑 레벨의 도메인의 존의 관리를, 탑 레벨 도메인의 권위 서버에 위임한다. 마지막까지 도달하면 그 권한 서버로부터 도메인 이름에 대응하는 IP 주소를 받는다.
            - DNS 클라이언트가 www.example.co.kr IP 주소 요청
            - 캐시 서버는 루트 서버에 www.example.co.kr IP 주소 요청
            - 루트 서버는 kr을 관리하는 서버에 문의하라고 응답
            - 캐시 서버는 kr 서버에 www.example.co.kr IP 주소 요청
            - kr 서버는 co를 관리하는 서버에 문의하라고 응답
            - 캐시 서버는 co 서버에 www.example.co.kr IP 주소 요청
            - co 서버는 example을 관리하는 서버에 문의하라고 응답
            - 캐시 서버는 example 서버에 www.example.co.kr IP 주소 요청
            - example 서버는 www.example.co.kr IP 주소를 응답
            - 캐시 서버는 DNS 클라이언트에 www.example.co.kr IP 주소를 응답
 - `DNS 서버 자동화와 존 전송`
    - __캐시 서버 다중화__
        - 캐시 서버는 DNS 클라이언트가 요청한 이름 결정 정보를 캐시한다.
        - 프라이머리 DNS 서버와 세컨더리 DNS 서버 사이에서 무언가 정보를 동기화할 필요없이, DNS 클라이언트 측에 프라이머리 DNS와 세컨더리 DNS 서버를 지정하면 된다.
    - __권위 서버 다중화__
        - 권위 서버는 자신이 관리하는 도메인에 관한 정보(존 파일)를 유지하는 중요한 서버다.
        - 프라이머리 서버가 중단되어도 세컨더리 DNS 서버로 같은 정보를 반환할 수 있도록 같은 존 파일을 보존해야한다. 때문에, DNS 서버 사이에서 존 파일을 동기화하는 존 전송이 필요하다.
 - `존 파일과 리소스 레코드`
    - 하나의 존 파일로 관리하는 도메인 이름의 범위를 존이라고 부른다.
    - 존 파일은 여러 종류의 리소스 레코드로 구성되어 있으며, 그 안에 모든 존이 들어있다.
    - 권위 서버는 존 파일의 정보에 기반해 반복 쿼리에 응답한다.

<br/>

### DNS 메시지 포맷

DNS 메시지는 Header 섹션, Question 섹션, Answer 섹션, Authority 섹션, Additional 섹션 5개 섹션으로 구성된다.  


 - Header 섹션: 제어 정보
 - Question 섹션: DNS 서버에 대한 질문
 - Answer 섹션: DNS 서버 응답의 리소스 레코드
 - Authority 섹션: 권위 서버의 리소스 레코드
 - Additional 섹션: 부가 정보를 나타내는 리소스 레코드

<br/>

### DNS를 이용한 기능

DNS는 HTTP 패킷이나 HTTPS 패킷, 메일 패킷의 행선지를 결정하는 중요한 역할을 담당한다.  

 - `DNS 라운드 로빈`
    - DNS 라운드 로빈은 DNS를 이용한 부하 분산 기술이다.
    - 권위 서버에 하나의 도메인(FQDN)에 여러 IP 주소를 등록하여 DNS 쿼리를 받을 때 마다 순서대로 다른 IP 주소를 반환하도록 한다.
    - 클라이언트는 같은 도메인 이름으로 다른 서버에 접속할 수 있어 서버 부하를 분산할 수 있다.
 - `광역 부하 분산`
    - 지리적으로 떨어져 있는 사이트에 있는 서버에 통신을 할당해 부하를 분산하는 기술을 광역 부하 분산이라 부른다.
    - 광역 부하 분산 기술은 부하 분산 장치나 클라우드 서비스의 광역 부하 분산 기능이 있는 권위 서버가 되며 IP 주소를 반환한다.
    - 각 사이트의 상태를 감시하고 그 결과에 따라 응답하는 IP 주소를 바꿈으로써 부하를 유연하게 분산한다.
 - `CDN`
    - CDN은 웹 콘텐츠를 대량 송신하기 위해 최적화된 인터넷상 서버 네트워크이다.
    - 오리지널 컨텐츠를 가진 오리진 서버와 그 캐시를 가진 엣지 서버로 구성된다.
    - CDN 자체는 DNS에 특화된 기능이 아니라, 사용자를 물리적으로 더 가까운 엣지 서버로 유도하기 위해 DNS를 사용한다.
       - 클라이언트 DNS로 권위 서버 도메인 요청 -> 권위 서버는 CDN 서버 도메인 반환 -> 클라이언트 DNS는 CDN 권위 서버에 도메인 요청 -> CDN 권위 서버는 클라이언트 IP에 가까운 엣지 서버 IP 반환
       - 권위 서버의 존 파일은 CDN의 권위 서버의 FQDN을 CNAME 레코드(별명)로 등록한다.
       - 권위 서버는 클라이언트의 DNS 쿼리를 받으면 CDN의 권위 서버의 FQDN을 반환한다.
       - DNS 라이브러리를 받은 클라이언트는 CDN의 권위 서버에 DNS 쿼리를 송신하고, CDN의 권위 서버는 클라이언트의 IP 주소를 보고 가장 가까운 엣지 서버의 IP 주소를 반환한다.

<br/>

## 메일 계열 프로토콜

메일은 송신과 수신에 각각 다른 프로토콜을 사용한다.

<br/>

### 메일 송신 프로토콜

메일 송신에는 SMTP(Simple Mail Transfer Protocol)를 사용한다.  
SMTP는 클라이언트의 리퀘스트에 대해 서버가 리플라이를 반환하는 전형적인 클라이언트 서버 타입 프로토콜이다.  
이름에 'Simple'이 포함된만큼 매우 간단한 프로토콜이지만, 보안 문제를 안고 있어 인증하거나 암호화하는 등 다양한 형태로 확장해서 사용한다.  

 - `SMTP`
    - RFC5321로 표준화된 프로토콜로 TCP 25번을 사용한다.
    - 메일 소프트웨어(SMTP 클라이언트)는 메일 서버에 대해 메일을 보낼 때 SMTP를 사용한다.
    - __SMTP 흐름__
        - 메일 서버는 메일 소프트웨어로부터 메일을 받으면 수신지 메일 주소의 앳 마크(@) 뒤에 기술된 FQDN을 보고 DNS 서버로 MX 레코드를 문의한다.
        - DNS 서버에 의해 상대 메일 서버의 IP 주소를 확인하면 그 IP 주소에 대해 메일을 송신한다.
        - 메일을 받은 수신측 메일 서버는 수신지 메일 주소의 @ 마크의 양쪽에 기술된 사용자 이름을 보고, 사용자별로 제공한 저장소 영역 메일 박스로 메일을 나누고 저장한다.
    - __인증 기능__
        - 인증에 관한 확장 기능에는 SMTP 인증과 POP before SMTP 2가지 종류가 있다.
        - SMTP 인증: RFC 4954에 표준화된 사용자 인증 기능으로 TCP 587번을 사용한다. 메일 서버는 메일을 송신하기 전에 사용자 이름과 비밀번호로 사용자를 체크한다. 인증 성공시 메일을 받는다.
        - POP before SMTP: POP을 이용한 사용자 인증 기능으로 POP은 메일을 수신할 때 사용하는 프로토콜로 기본적으로 메일 수신전 사용자 인증을 진행한다. 이러한 인증 기능을 응용하여 메일 클라이언트가 메일을 송신하기 전에 POP으로 인증을 진행한다.
    - __암호화 기능__
        - 암호화에는 SMPTS를 사용한다.
        - SMTPS는 최초에 서로가 SMTPS에 대응하고 있는 것을 STARTTLS라는 SMTP의 확장 기능을 사용해 확인한다.

<br/>

### 메일 수신 프로토콜

SMTP에 의해 전송된 메일은 메일 서버의 메일 박스에 저장된다.  
사용자는 메일 박스로부터 POP3(Post Office Protocol version 3)나 IMAP(Internet Message Access Protocol)이라는 프로토콜을 사용해 자신의 메일을 추출한다.  

 - `POP3`
    - POP3는 RFC1939로 표준화된 프로토콜로 TCP 110번을 사용한다.
    - POP3 서버는 메일 소프트웨어에서 받은 사용자 이름과 비밀번호를 인증한다. 그리고 인증에 성공하면 메일 박스에서 메일을 추출해 메일 데이터로 전송한다.
    - __암호화 기능__
        - RFC로 표준화된 오리지널 POP3는 인증 기능은 있으나 암호화 기능은 없으므로 경로 도중에 도출될 수 있다. 때문에, SMTP와 같이 확장 기능을 이용해 암호화를 한다.
        - 암호화에 관한 확장 기능에는 APOP와 POP3S 2가지 종류가 있다.
        - APOP: 해시 함수를 이용해 비밀번호를 암호화하는 기능으로 메일 본문은 암호화되지 않는다. TCP 110번 포트를 사용한다.
        - POP3S: POP3를 SSL/TLS로 암호화하는 기능으로 3 Way Handshake 과정으로 인증이나 키 교환을 수행한 뒤에 POP3로 메일 데이터를 교환한다. TCP 995 포트를 사용한다.
 - `IMAP4`
    - IMAP4는 RFC3501로 표준화된 프로토콜로 TCP 143번을 사용한다.
    - POP3는 메일을 메일 서버로부터 다운로드하고, 메일 소프트웨어에 저장/관리하며, 메일 서버의 메일은 삭제된다.
    - IMAP4는 메일을 메일 서버에 남긴 채, 메일 소프트웨어에서 열람할 수 있다.
    - 단말에 메일을 저장하지 않고, 메일 서버에서 메일을 일괄 관리할 수 있다.
    - __암호화 기능__
        - RFC로 표준화된 오리지널 IMAP4는 인증 기능은 있으나 암호화 기능은 없으므로 경로 도중에 도출될 수 있다.
        - IMAP4는 SSL/TLS로 암호화한 IMAP4S로 확장하며, TCP 993번을 사용한다.
 - `POP3와 IMAP4 비교`
    - POP3는 단말에 저장되어 서버 스토리지 영역을 절약하며, 오프라인 상태에서도 메일을 관리할 수 있다. 하지만, 여러 단말에 메일을 일괄적으로 관리할 수 없다.
    - IMAP4는 메일 서버에서 메일이 저장되어 여러 단말에서 메일 서버에 요청하여 일괄적으로 관리할 수 있다. 하지만, 서버 스토리지 영역이 줄어들고 오프라인 상태에서는 메일을 관리할 수 없다.
    - 떄문에, 1대의 단말에서 메일을 이용하는 사용자는 POP3를 사용하고, 여러 단말에서 메일을 이용하는 사용자는 IMAP4를 이용할 수 있다.

<br/>

### 웹메일

웹 메일은 웹브라우저를 사용해서 메일을 송수신하거나 편집할 수 있는 서비스이다.  
웹 메일의 경우 웹브라우저가 메일 클라이언트가 되고, 메일 서버와의 교환은 HTTPS로 수행한다.  
 - 1번: 웹브라우저를 사용해 웹메일 서버에 HTTPS로 액세스한다. 이떄, 사용자 ID와 비밀번호로 인증한다.
 - 2번: 웹메일 서버는 DNS로 상대편 웹메일 서버의 IP 주소를 찾고, 그 IP 주소에 대해 SMTP로 메일을 전송한다.
 - 3번: 상대편 웹메일 서버는 받은 메일을 사용자별로 제공하는 메일 박스에 저장한다.
 - 4번: 수신지 메일 주소의 사용자는 웹브라우저를 사용해, 웹메일 서버에 액세스한다.

<br/>

## 관리 액세스 프로토콜

관리 액세스 프로토콜은 원격에서 네트워크 기기의 정보를 확인하거나 설정할 때 사용하는 프로토콜이다.  
관리 액세스 사용자 인터페이스로는 그래픽 기반의 GUI와 텍스트 기반의 CLI 2가지 종류가 있다.  

 - `GUI(그래픽 기반)`
    - 사용 소프트웨어: 웹브라우저
    - 비암호화 프로토콜: HTTP
    - 암호화 프로토콜: HTTPS
 - `CLI(텍스트 기반)`
    - 사용 소프트웨어: 터미널 소프트웨어
    - 비암호화 프로토콜: Telnet
    - 암호화 프로토콜: SSH(Secure Shell)

<br/>

### Telnet

Telnet은 RFC854로 표준화된 관리 액세스 프로토콜이다.  
가장 원시적이며 단순한 프로토콜로 애플리케이션 헤더가 없고 애플리케이션 페이로드에 명려어나 ASCII 코드 텍스트 데이터를 그대로 저장한다.  

기본적으로 TCP 23번 포트를 사용하지만, 포트 번호를 변경할 수 있어 HTTP/1.1이나 SMTP, POP, IMAP 등과 같은 텍스트 데이터를 교환하는 애플리케이션 명령어 처리를 실행하는 등 다양하게 사용할 수 있다.  
비밀번호를 포함한 모든 데이터가 암호화되지 않은 평문으로 교환되어 보안상 문제가 있을 수 있다.  

 - `Telent을 이용한 트러블 슈팅`
    - 트랜스포트 계층에서 Telnet으로 접속 시도해봄으로써 3 Way Handshake를 확립할 수 있는지 TCP 레벨의 소통을 확인할 수 있다.
    - 또한, 암호화를 수반하지 않는 텍스트 계열 애플리케이션이라면 명령어를 입력해 애플리케이션 레벨의 소통을 확인할 수 있다.
    - 4계층(트랜스포트 계층)
        - 주요 도구: Telnet
        - 주요 확인 항목: 포트 번호, 커넥션 테이블, 필터링 규칙, NAT 테이블
    - 3계층(네트워크 계층)
        - 주요 도구: ping, traceroute
        - 주요 확인 항목: IP 주소, 라우팅 테이블, 필터링 규칙, NAT 테이블
    - 2계층(데이터링크 계층)
        - 주요 도구: arp
        - 주요 확인 항목: MAC 주소, MAC 주소 테이블, ARP 테이블
    - 1계층(물리 계층)
        - 주요 도구: 케이블 테스터, 와이파이 안테나
        - 주요 확인 항목: LAN 케이블, 전파

<br/>

### SSH

SSH는 RFC4253에 표준화된 관리 액세스 프로토콜로 TCP 22번을 사용한다.  
SSH를 사용하면 데이터가 암호화되어 도청되어도 확인할 수 없고, 비밀키가 유출되지 않는한 무차별 대입 공격에도 로그인할 수 없어 안전하게 사용할 수 있다.  

- `파일 전송`
    - SSH를 이용한 파일 전송 기능은 SCP와 SFTP 2가지 종류가 있다.
    - SCP
        - TCP 22번 포트를 사용하며 단순한 기능을 제공한다.
        - 비대화형으로 로컬 단말과 리모트 단말 사이에 파일 전송 기능을 제공한다.
    - SFTP
        - TCP 22번 포트를 사용하며 다양한 기능을 제공한다.
        - 대화형으로 로컬 단말과 리모트 단말 사이에서 파일 전송 기능을 제공한다.
        - 리모트 단말의 파일/디렉토리 삭제와 파일 리스트 열람 등을 제공한다.
 - `포트 포워딩`
    - 포트 포워딩은 특정한 포트 번호에 대한 통신을 SSH로 만든 암호화 통신로를 사용해서 다른 단말에 전송하는 기능이다.

<br/>

### 운용 관리 프로토콜

운용 관리 프로토콜은 네트워크나 서버를 더욱 원만하게 운용/관리하기 위한 프로토콜이다.  

 - `NTP`
    - NTP는 네트워크 기기나 서버의 시각을 맞추기 위해 사용하는 프로토콜로 TFC7822로 표준화되었다.
    - NTP는 Stratum이라는 값을 이용한 계층 구조로 되어있다.
 - `SNMP`
    - SNMP는 네트워크 기기나 서버의 성능 감시, 장애 감시에 사용하는 프로토콜이다.
    - SNMP를 사용해 CPU 사용률이나 메모리 사용률, 트래픽양, 패킷양 등 다양한 관리 대상 기기 정보를 정기적으로 수집하고 지속적으로 감시해 장애 징후를 빠르게 감지한다.
    - __SNMP 버전__
        - v1(베이스): 커뮤니티 이름을 이용한 평문 인증을 진행하며, 암호화 기능이 없다.
        - v2(기능 추가): 커뮤니티 이름을 이용한 평문 인증을 진행하며, 암호화 기능이 없다.
        - v3(보안 강화): 사용자별 비밀번호 인증을 진행하며, 암호화 기능이 있다.
    - __SNMP 관리자와 SNMP 에이전트__
        - SNMP는 SNMP 관리자와 SNMP 에이전트로 구성된다.
        - SNMP 관리자는 SNMP 에이전트가 가진 관리 정보를 수집/감시하는 애플리케이션이다. Zabbix, TWSNMP 매니저 등이 있으며 수집한 정보를 가공해 웹 GUI 기반으로 가시화하여 보기 쉽게 만들어준다.
        - SNMP 에이전트는 SNMP 관리자의 요청을 받아 장애를 알리는 프로그램으로 대부분 네트워크 기기나 서버에 구현되어 있다.
 - `Syslog`
    - Syslog는 네트워크 기기나 서버의 로그를 전송하기 위해 사용되는 프로토콜로 RFC3164와 RFC5424로 표준화되었다.
    - 네트워크 기기나 서버는 다양한 이벤트를 로그로 기기 내부의 메모리나 하드 디스크에 일정 기간 저장하는데, Syslog는 이 로그를 Syslog 서버에 전송해서 로그를 일원화한다.
    - 단순히 어떤 이벤트가 발생하면 그것을 자신의 메모리나 디스크에 저장함과 동시에 Syslog 서버로 전송한다. 전송은 유니캐스트로 수행하며 UDP, TCP 모두 대응하지만 대부분 UDP로 수행한다.
    - __Syslog 구성 필드__
        - PRI: 로그의 종류를 나타내는 Facility와 긴급도를 나타내는 Severity가 저장된다.
        - 헤더: 타임 스탬프, 단말의 이름, IP 주소 등이 저장된다.
        - 메시지: 로그 메시지 자체가 텍스트 메시지로 저장된다.

