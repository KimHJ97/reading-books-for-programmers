# 접근 제어

## 1. 기본 개요

### 1-1. 리소스와 소유권

리눅스는 다중 사용자 운영체제로 유닉스로부터 사용자 개념을 물려받았다. 각 사용자 계정은 실행 파일, 파일, 장치, 기타 리눅스 자산에 접근할 수 있는 사용자 ID와 연결된다.  

 - __사용자__: 프로세스를 실행하고 파일을 소유한다. 프로세스는 커널이 메인 메모리에 로드해 실행하는 일종의 프로그램이다.
 - __파일__: 소유자가 존재한다. 기본적으로 파일을 만든 사용자가 파일을 소유한다.
 - __프로세스__: 의사소통과 지속성을 위해 파일을 사용한다.

<br/>

### 1-2. 샌드박스

리눅스에서 "샌드박스(Sandbox)"란, 애플리케이션이나 프로세스를 격리된 환경에서 실행하여 시스템의 보안을 유지하고 안전한 테스트 환경을 제공하는 기술입니다. 샌드박스는 애플리케이션이 시스템의 다른 부분에 영향을 미치지 못하도록 격리하는 데 사용됩니다. 이는 악성 코드나 잘못된 동작으로부터 시스템을 보호하고 사용자의 개인 정보를 안전하게 보호하는 데 도움이 됩니다.  

<br/>

### 1-3. 접근 제어 유형

다양한 접근 제어 유형이 있으나 리눅스 관점에서 가장 중요하고 관련성이 높은 두 가지는 임의 접근 제어와 강제 접근제어다.  

 - __임의 접근 제어__: 임의 접근 제어(DAC)를 사용하면 사용자의 신분을 기반으로 리소스에 대한 접근을 제한할 수 있다. 임의라 함은 특정 권한을 가진 사용자가 이를 다른 사용자에게 전달할 수 있음을 뜻한다.
 - __강제 접근 제어__: 강제 접근 제어(MAC)는 보안 수준을 나타내는 계층 모델을 기반으로 한다. 사용자에게는 허용 등급이 할당되고 리소스에는 보안 레이블이 할당된다. 사용자는 자신의 허용 등급 이하로 설정된 리소스에만 접근할 수 있다. 강제 접근 제어 모델에서는 관리자가 모든 권한을 설정하여 엄격하고 배타적으로 접근을 제어한다.

<br/>

## 2. 사용자

리눅스에서는 목적 또는 의도적인 사용 관점에서 사용자 계정을 두 가지 유형으로 구분한다.  

 - __시스템 사용자 또는 시스템 계정__: 일반적으로 프로그램은 이런 유형의 계정을 사용하여 백그라운드 프로세스를 실행한다.
 - __일반 사용자__: 셸을 통해 리눅스를 대화식으로 사용하는 인간 사용자 유형

<br/>

리눅스는 UID를 통해 사용자를 식별하며, 사용자 그룹 ID를 통해 식별되는 하나 이상의 그룹에 속한다.  
일반적으로 root라고 하는 UID 0을 가진 특별한 종류의 사용자가 있는데, 이 슈퍼유저는 무엇이든 할 수 있어 제한이 적용되지 않는다.  
때문에, root 사용자로 작업하는 것을 피해야 한다. 주의하지 않으면 자칫 시스템을 파괴하기 쉽다.  

 - UID 0: root 사용자
 - UID 1 ~ 999: 시스템 사용자에게 지정됨
 - UID 65534: nobody 사용자.
 - UID 1000 ~ 65533, 65536 ~ 4294967294: 일반 사용자

<br/>

### 2-1. 로컬에서 사용자 관리하기

시스템에 로컬로 저장된 정보만 사용되며 사용자 관련 정보는 시스템 네트워크에서 공유되지 않는다.  
로컬 사용자 관리를 위해 리눅스는 간단한 파일 기반 인터페이스를 사용한다.  

 - __로컬 사용자 관리 파일 참조__
    - 사용자 데이터베이스: /etc/passwd
    - 그룹 데이터베이스: /etc/group
    - 사용자 비밀번호: /etc/shadow
    - 그룹 비밀번호: /etc/gshadow

```bash
$ cat /etc/passwd
root:x:0:0:root:/root:/bin/bash

# 1. root: 사용자 이름(32자 이하)
# 2. x: 사용자의 비밀번호. x 문자는 비밀번호가 /etc/shadow에 저장됨을 의미한다.
# 3. 0: UID. 리눅스는 1000 미만의 UID는 시스템 사용을 위해 예약해 둔다.
# 4. 0: 사용자의 기본 그룹(GID). /etc/group 참조
# 5. root: 이름 또는 전화번호 같은 연락처 데이터 등의 사용자 정보
# 6. /root: 사용자 홈 디렉토리
# 7. /bin/bash: 사용할 로그인 셸. 대화식 로그인을 이용하지 않으려면 /sbin/nologin 이용
```
<br/>

 - `사용자 추가`
```bash
$ sudo adduser hello
```
<br/>

### 2-2. 중앙집중식 사용자 관리

전문적인 설정으로 사용자를 관리해야 하는 시스템이나 서버가 둘 이상인 경우, 중앙에서 사용자를 관리하지만 하나의 특정 시스템에 로컬로 적용할 수 있는 관리 방식이 필요하다.  

 - __디렉토리 기반__: LDAP는 수십 년 된 프로토콜 제품군으로 현재 IETF에서 공식화되어 있으며, IP를 통해 분산 디렉토리에 접근하고 유지 관리하는 방법을 정의한다. 키클록 같은 프로젝트를 이용해 LDAP 서버를 직접 실행할 수도 있고, 애저 액티브 디렉토리 같은 클라우드 공급자의 제품을 사용할 수도 있다.
 - __네트워크 이용__: 커버로스를 사용하면 네트워크로 사용자를 인증할 수 있다.
 - __구상 관리 시스템 사용__: 앤서블, 셰프, 퍼핏, 솔트스택 등의 시스템들을 사용해 여러 컴퓨터에서 일관되게 사용자를 생성할 수 있다.

<br/>

## 3. 권한

### 3-1. 파일 권한

파일 권한은 리소스에 접근한다는 리눅스 개념의 핵심이다. 리눅스에서는 모든 것이 파일이다.  

 - __접근 유형__
    - 읽기(r)
        - 일반 파일의 경우 사용자가 파일 내용을 볼 수 있다.
        - 디렉토리의 경우 사용자는 디렉토리에 있는 파일 이름을 볼 수 있다.
    - 쓰기(w)
        - 일반 파일의 경우 사용자가 파일을 수정하고 삭제할 수 있다.
        - 디렉토리의 경우 사용자가 디렉토리에서 파일을 만들고 이름을 바꾸고 삭제할 수 있다.
    - 실행(x)
        - 이 옵션을 켜면 사용자가 읽기 권한도 가지고 있는 경우 이 파일을 실행할 수 있다.
        - 디렉토리의 경우 사용자가 디렉토리의 파일 정보에 접근할 수 있도록 허용해 사실상 사용자가 디렉토리로 이동(cd)하거나 내용을 나열(ls) 할 수 있게 만든다.

```bash
$ ls -al
total 0
-rw-r--r-- 1 hello devs 9 Apr 12 11:42 test

# 1. -rw-r--r--: 파일 모드
# 2. 1: 하드링크 개수
# 3. hello: 파일 소유자
# 4. devs: 파일이 속한 그룹
# 5. 9: 파일 크기(바이트)
# 6. Apr 12 11:42: 마지막으로 수정한 타임스탬프
# 7. test: 파일 이름
```
<br/>

#### 파일 권한 예시

```
★ 권한 없음
패턴: ---
십진법 표기: 0

★ 실행 권한
패턴: --x
십진법 표기: 1

★ 쓰기 권한
패턴: -w-
십진법 표기: 2

★ 쓰기&실행 권한
패턴: -wx
십진법 표기: 3

★ 읽기
패턴: r--
십진법 표기: 4

★ 읽기&실행 권한
패턴: r-x
십진법 표기: 5

★ 읽기&쓰기
패턴: rw-
십진법 표기: 6

★ 읽기&쓰기&실행
패턴: rwx
십진법 표기: 7
```
<br/>

#### 파일 권한 정리

644는 기본적으로 파일을 만들 때 할당하는 기본 권한이다. 이런 정보는 umask 명령으로 확인할 수 있다.  

 - __755__: 소유자는 모든 권한을 가지며, 그 외 모든 사람은 읽기와 쓰기 권한을 가짐
 - __700__: 소유자는 모든 권한을 가지며, 그 외 모든 사람은 아무 권한이 없음
 - __664__: 소유자와 그룹은 읽기/쓰기 권한이 있으며, 나머지 사용자는 읽기만 가능
 - __644__: 소유자는 읽고 쓰기가 가능하며, 그 외 모든 사람은 읽기만 가능
 - __400__: 소유자만 읽기만 가능

<br/>

## 4. 프로세스 권한

 - __RUID__: RUID는 프로세스를 시작한 사용자의 UID다.
 - __EUID__: 리눅스 커널은 메시지 대기열과 같은 공유 리소스에 접근할 때 EUID를 사용해 프로세스가 갖는 권한을 결정한다.
 - __저장된 SUID__: 저장된 SUID는 프로세스가 실제 UID과 저장된 SUID 사이에서 유효 UID를 전환함으로써 권한을 가정할 수 있을 때 사용된다.
 - __FUID__: FUID는 리눅스 전용 ID로서 파일 접근 권한을 결정하는 데 사용됐으며, 원래 파일 서버가 일반 사용자를 대행해서 동작하되 해당 사용자가 보내는 시그널로부터 프로세스를 격리하는 사용 사례를 지원하기 위해 도입됐다.

<br/>

## 5. 고급 권한 관리

### 5-1. 캐퍼빌리티

"캐퍼빌리티(Capability)"는 리눅스 시스템에서 프로세스나 사용자에게 특정한 시스템 리소스나 권한을 부여하는 보안 메커니즘입니다. 이는 전통적인 UNIX 시스템의 권한 관리 방식인 "유저 ID(UID)와 그룹 ID(GID)"를 보완하여 보다 세밀한 권한 관리가 가능하도록 합니다.  
 - 미세한 권한 제어: 캐퍼빌리티는 프로세스가 필요한 권한만을 가질 수 있도록 합니다. 이는 프로세스가 시스템 리소스에 대한 너무 많은 권한을 가지지 않고, 권한의 최소한으로 실행되도록 보장합니다.
 - 루트 권한 획득 방지: 캐퍼빌리티는 루트 권한이 필요한 작업을 분할하여, 프로세스가 루트 권한을 획득하지 않고도 특정한 작업을 수행할 수 있도록 합니다. 이는 시스템의 보안을 향상시키는데 도움이 됩니다.
 - 동적으로 부여될 수 있는 권한: 캐퍼빌리티는 프로세스가 실행되는 동안 필요한 권한을 동적으로 부여할 수 있습니다. 이는 시스템 리소스에 대한 접근이 필요한 특정한 작업이 발생할 때마다 권한을 부여하여 보안을 강화할 수 있습니다.
 - 보안 강화: 캐퍼빌리티는 시스템의 보안을 향상시키는데 도움이 됩니다. 프로세스가 필요한 권한만을 가지고 실행되므로, 잠재적인 보안 위협이나 공격을 방지하는 데 유용합니다.

<br/>

#### 유용한 캐퍼빌리티의 예

 - CAP_CHOWN: 사용자가 파일의 UID/GID를 임의로 변경할 수 있게 허용한다.
 - CAP_KILL: 다른 사용자에게 속한 프로세스에 신호를 보낼 수 있게 허용한다.
 - CAP_SETUID: UID를 변경할 수 있게 허용한다.
 - CAP_SETPCAP: 실행 중인 프로세스의 캐퍼빌리티를 설정할 수 있게 허용한다.
 - CAP_NET_ADMIN: 인터페이스 구성과 같은 다양한 네트워크 관련 작업을 허용한다.
 - CAP_NET_RAW: RAW와 PACKET 소켓의 사용을 허용한다.
 - CAP_SYS_CHROOT: chroot의 호출을 허용한다.
 - CAP_SYS_ADMIN: 파일시스템 마운트를 포함한 시스템 관리 작업을 허용한다.
 - CAP_SYS_PIRACE: strace를 사용하여 프로세스를 디버그할 수 있게 허용한다.
 - CAP_SYS_MODULE: 커널 모듈의 로딩을 허용한다.

<br/>

#### 캐퍼빌리티 사용 예시

getcap과 setcap을 사용하면 캐퍼빌리티를 세분화된 방식, 즉 파일 단위로 관리할 수 있다.  

```bash
# 시스템의 모든 캐퍼빌리티의 개요
$ capsh --print

# 현재 프로세스(셸)의 캐퍼빌리티
$ grep Cap /proc/$$/status

# 1. getcap 명령어는 특정 파일의 캐퍼빌리티를 조회한다.
# /usr/bin/ping 파일에 부여된 캐퍼빌리티 조회
$ getcap /usr/bin/ping

# 2. setcap 명령어는 파일에 캐퍼빌리티를 설정한다. (root 권한 필요)
# /usr/bin/my_program 파일에 cap_net_raw 캐퍼빌리티 설정: root 권한 없이 raw 소켓에 접근 가능
$ sudo setcap cap_net_raw+ep /usr/bin/my_program
```
<br/>

### 5-2. seccomp 프로필

Seccomp는 "secure computing mode"의 약자로, 리눅스 커널에서 제공하는 보안 기능 중 하나입니다. Seccomp를 사용하면 애플리케이션의 시스템 호출을 제한하여 시스템의 보안을 강화할 수 있습니다. Seccomp는 특히 신뢰할 수 없는 코드나 프로세스를 실행할 때 사용됩니다.  

Seccomp 프로필은 Seccomp 필터링 정책을 지정하는 것을 의미합니다. Seccomp를 사용하면 특정 프로세스에 대해 허용되는 시스템 호출을 제한할 수 있으며, 이를 통해 시스템에 대한 공격을 방지하거나 보안 취약점을 줄일 수 있습니다.  

<br/>

### 5-3. 접근 제어 목록


접근 제어 목록(Access Control List, ACL)은 파일 시스템에서 파일이나 디렉터리에 대한 접근 권한을 세부적으로 제어하기 위한 메커니즘입니다. 기본적으로 리눅스 파일 시스템은 소유자, 그룹 및 기타 사용자에 대한 읽기, 쓰기, 실행과 같은 기본적인 접근 권한을 설정할 수 있습니다. 그러나 ACL은 이러한 기본적인 권한을 보완하여 더 세밀한 접근 제어를 가능하게 합니다.  
 - 세분화된 권한 설정: ACL을 사용하면 파일이나 디렉터리에 대한 접근 권한을 세분화하여 설정할 수 있습니다. 예를 들어, 특정 사용자나 그룹에 대해 읽기, 쓰기, 실행과 같은 다양한 권한을 지정할 수 있습니다.
 - 다양한 사용자 및 그룹 지정: ACL을 사용하면 파일이나 디렉터리에 대한 접근 권한을 지정할 때 다양한 사용자 및 그룹을 명시할 수 있습니다. 이를 통해 다수의 사용자나 그룹에 대한 접근 권한을 효율적으로 관리할 수 있습니다.
 - 유연한 권한 관리: ACL을 사용하면 기본적인 소유자, 그룹 및 기타 사용자에 대한 권한 이외에도 추가적인 권한을 부여할 수 있습니다. 이는 특정 사용자나 그룹에 대해 특정 파일에만 접근 권한을 제한할 수 있도록 합니다.

```bash
# ACL 설정
# myfile.txt 파일에 대해 user1 사용자에게 읽기(r)와 쓰기(w) 권한을 추가
$ setfacl -m u:user1:rw myfile.txt

# ACL 조회
# myfile.txt 파일에 대한 ACL을 출력
$ getfacl myfile.txt

# ACL 제거
# myfile.txt 파일에 설정된 모든 ACL을 제거
$ setfacl -b myfile.txt
```

